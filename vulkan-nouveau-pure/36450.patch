From a2212fd58648eb4ecb9e523a09741e8b1ebfca78 Mon Sep 17 00:00:00 2001
From: Mohamed Ahmed <mohamedahmedegypt2001@gmail.com>
Date: Tue, 22 Jul 2025 21:01:01 +0300
Subject: [PATCH 1/6] nvk/nvkmd: Fix alignments

Previously, there was some mixing up of alignments between the alignment
provided by the caller, and the minimum alignment we have (4KiB). Additionally,
there was some redundant aligning being done to data already passed in aligned.
This didn't matter because we were always using 4K pages anyways due to kernel
limitations. However, this now needs fixing to allow for larger page support.
---
 .../vulkan/nvkmd/nouveau/nvkmd_nouveau_mem.c  | 22 ++++++++++++++-----
 .../vulkan/nvkmd/nouveau/nvkmd_nouveau_va.c   | 10 ++++++---
 2 files changed, 23 insertions(+), 9 deletions(-)

diff --git a/src/nouveau/vulkan/nvkmd/nouveau/nvkmd_nouveau_mem.c b/src/nouveau/vulkan/nvkmd/nouveau/nvkmd_nouveau_mem.c
index 4c93e25fe3d42..96e3959da6b5b 100644
--- a/src/nouveau/vulkan/nvkmd/nouveau/nvkmd_nouveau_mem.c
+++ b/src/nouveau/vulkan/nvkmd/nouveau/nvkmd_nouveau_mem.c
@@ -40,8 +40,14 @@ create_mem_or_close_bo(struct nvkmd_nouveau_dev *dev,
       goto fail_bo;
    }
 
+   /* If the bo is VRAM pinned, we should use the VA alignment as it's larger
+    * and has compression, thus allowing for higher perf. Otherwise, for GART
+    * we stick to 4K alignment as that's required for system RAM.
+    */
+   uint32_t mem_bind_align_B = (mem_flags & NVKMD_MEM_VRAM) ? va_align_B :
+                               dev->base.pdev->bind_align_B;
    nvkmd_mem_init(&dev->base, &mem->base, &nvkmd_nouveau_mem_ops,
-                  mem_flags, size_B, dev->base.pdev->bind_align_B);
+                  mem_flags, size_B, mem_bind_align_B);
    mem->bo = bo;
 
    result = nvkmd_dev_alloc_va(&dev->base, log_obj,
@@ -122,11 +128,15 @@ nvkmd_nouveau_alloc_tiled_mem(struct nvkmd_dev *_dev,
    if (force_mem_to_gart(dev->base.pdev, flags))
       domains = NOUVEAU_WS_BO_GART;
 
-   const uint32_t mem_align_B = _dev->pdev->bind_align_B;
-   size_B = align64(size_B, mem_align_B);
-
+   /* There's no need to align again because the size we get from the callers
+    * is already aligned. However, just in case, add in a minimum of alignment
+    * of 4KiB, and also if not aligned, ensure that the size is aligned.
+    */
+   const uint32_t min_align_B = _dev->pdev->bind_align_B;
    assert(util_is_power_of_two_or_zero64(align_B));
-   const uint64_t va_align_B = MAX2(mem_align_B, align_B);
+   const uint64_t va_align_B = MAX2(min_align_B, align_B);
+   if (size_B % va_align_B != 0)
+      size_B = align64(size_B, va_align_B);
 
    enum nouveau_ws_bo_flags nouveau_flags = domains;
    if (flags & NVKMD_MEM_CAN_MAP)
@@ -135,7 +145,7 @@ nvkmd_nouveau_alloc_tiled_mem(struct nvkmd_dev *_dev,
       nouveau_flags |= NOUVEAU_WS_BO_NO_SHARE;
 
    struct nouveau_ws_bo *bo = nouveau_ws_bo_new_tiled(dev->ws_dev,
-                                                      size_B, mem_align_B,
+                                                      size_B, va_align_B,
                                                       pte_kind, tile_mode,
                                                       nouveau_flags);
    if (bo == NULL)
diff --git a/src/nouveau/vulkan/nvkmd/nouveau/nvkmd_nouveau_va.c b/src/nouveau/vulkan/nvkmd/nouveau/nvkmd_nouveau_va.c
index 922215d88898f..539e5d31d5110 100644
--- a/src/nouveau/vulkan/nvkmd/nouveau/nvkmd_nouveau_va.c
+++ b/src/nouveau/vulkan/nvkmd/nouveau/nvkmd_nouveau_va.c
@@ -125,12 +125,16 @@ nvkmd_nouveau_alloc_va(struct nvkmd_dev *_dev,
    if (va == NULL)
       return vk_error(log_obj, VK_ERROR_OUT_OF_HOST_MEMORY);
 
+   /* There's no need to align again because the size we get from the callers
+    * is already aligned. However, just in case, add in a minimum of alignment
+    * of 4KiB, and also if not aligned, ensure that the size is aligned.
+    */
    const uint32_t min_align_B = _dev->pdev->bind_align_B;
-   size_B = align64(size_B, min_align_B);
-
    assert(util_is_power_of_two_or_zero64(align_B));
    align_B = MAX2(align_B, min_align_B);
-
+   if (size_B % align_B != 0)
+      size_B = align64(size_B, align_B);
+   
    assert((fixed_addr == 0) == !(flags & NVKMD_VA_ALLOC_FIXED));
 
    result = alloc_heap_addr(dev, log_obj, flags, size_B, align_B,
-- 
GitLab


From 0804f74c33c51f0f62b9551e4596d67bf6a9652f Mon Sep 17 00:00:00 2001
From: Faith Ekstrand <faith.ekstrand@collabora.com>
Date: Fri, 29 Aug 2025 16:21:06 -0400
Subject: [PATCH 2/6] nvk: Add a dedicated_image to nvk_device_memory

Also refactor the dedicated image handling a tiny bit to make the next
bit easier.
---
 src/nouveau/vulkan/nvk_device_memory.c | 18 ++++++++++--------
 src/nouveau/vulkan/nvk_device_memory.h |  3 +++
 2 files changed, 13 insertions(+), 8 deletions(-)

diff --git a/src/nouveau/vulkan/nvk_device_memory.c b/src/nouveau/vulkan/nvk_device_memory.c
index 9f6aaa9f908d4..1712dbae5c0f4 100644
--- a/src/nouveau/vulkan/nvk_device_memory.c
+++ b/src/nouveau/vulkan/nvk_device_memory.c
@@ -130,6 +130,11 @@ nvk_AllocateMemory(VkDevice device,
    struct nvk_device_memory *mem;
    VkResult result = VK_SUCCESS;
 
+   mem = vk_device_memory_create(&dev->vk, pAllocateInfo,
+                                 pAllocator, sizeof(*mem));
+   if (!mem)
+      return vk_error(dev, VK_ERROR_OUT_OF_HOST_MEMORY);
+
    const VkImportMemoryFdInfoKHR *fd_info =
       vk_find_struct_const(pAllocateInfo->pNext, IMPORT_MEMORY_FD_INFO_KHR);
    const VkExportMemoryAllocateInfo *export_info =
@@ -152,10 +157,12 @@ nvk_AllocateMemory(VkDevice device,
       alignment = (1ULL << 16);
 
    uint8_t pte_kind = 0, tile_mode = 0;
-   if (dedicated_info != NULL) {
+   if (dedicated_info != NULL && dedicated_info->image != VK_NULL_HANDLE) {
       VK_FROM_HANDLE(nvk_image, image, dedicated_info->image);
-      if (image != NULL &&
-          image->vk.tiling == VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT) {
+
+      mem->dedicated_image = image;
+
+      if (image->vk.tiling == VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT) {
          /* This image might be shared with GL so we need to set the BO flags
           * such that GL can bind and use it.
           */
@@ -169,11 +176,6 @@ nvk_AllocateMemory(VkDevice device,
    const uint64_t aligned_size =
       align64(pAllocateInfo->allocationSize, alignment);
 
-   mem = vk_device_memory_create(&dev->vk, pAllocateInfo,
-                                 pAllocator, sizeof(*mem));
-   if (!mem)
-      return vk_error(dev, VK_ERROR_OUT_OF_HOST_MEMORY);
-
    const bool is_import = fd_info && fd_info->handleType;
    if (is_import) {
       assert(fd_info->handleType ==
diff --git a/src/nouveau/vulkan/nvk_device_memory.h b/src/nouveau/vulkan/nvk_device_memory.h
index 4d2f751f11160..cfceeae5352c8 100644
--- a/src/nouveau/vulkan/nvk_device_memory.h
+++ b/src/nouveau/vulkan/nvk_device_memory.h
@@ -11,11 +11,14 @@
 
 #include "util/list.h"
 
+struct nvk_image;
 struct nvkmd_mem;
 
 struct nvk_device_memory {
    struct vk_device_memory vk;
 
+   struct nvk_image *dedicated_image;
+
    struct nvkmd_mem *mem;
 };
 
-- 
GitLab


From 53de4a3d11bc2c9df418fbb6d10e8d033f195383 Mon Sep 17 00:00:00 2001
From: Mohamed Ahmed <mohamedahmedegypt2001@gmail.com>
Date: Tue, 29 Jul 2025 19:56:23 +0300
Subject: [PATCH 3/6] nil, nvk: Add plumbing for compression

This lays the groundwork for enabling compression by adding a way to pass in
whether the image will be compressed or not from NVK to NIL.
---
 src/nouveau/nil/image.rs       | 3 ++-
 src/nouveau/vulkan/nvk_image.c | 5 +++++
 2 files changed, 7 insertions(+), 1 deletion(-)

diff --git a/src/nouveau/nil/image.rs b/src/nouveau/nil/image.rs
index ecf137ce4bc22..01948c74e6914 100644
--- a/src/nouveau/nil/image.rs
+++ b/src/nouveau/nil/image.rs
@@ -157,6 +157,7 @@ pub struct ImageInitInfo {
     pub modifier: u64,
     pub explicit_row_stride_B: u32,
     pub max_alignment_B: u32,
+    pub compression: bool,
 }
 
 /// Represents the data layout of a single slice (level + lod) of an image.
@@ -366,7 +367,7 @@ impl Image {
             array_stride_B: 0,
             align_B: 0,
             size_B: 0,
-            compressed: false,
+            compressed: info.compression,
             tile_mode: 0,
             pte_kind: 0,
             mip_tail_first_lod: 0,
diff --git a/src/nouveau/vulkan/nvk_image.c b/src/nouveau/vulkan/nvk_image.c
index f24766244fa47..515eaf5139eba 100644
--- a/src/nouveau/vulkan/nvk_image.c
+++ b/src/nouveau/vulkan/nvk_image.c
@@ -775,6 +775,8 @@ nvk_image_init(struct nvk_device *dev,
       image->vk.stencil_usage |= VK_IMAGE_USAGE_SAMPLED_BIT;
    }
 
+   bool compression = false;
+
    if (image->vk.usage & VK_IMAGE_USAGE_TRANSFER_SRC_BIT)
       image->vk.usage |= VK_IMAGE_USAGE_SAMPLED_BIT;
    if (image->vk.usage & VK_IMAGE_USAGE_TRANSFER_DST_BIT)
@@ -889,6 +891,7 @@ nvk_image_init(struct nvk_device *dev,
             .levels = image->vk.mip_levels,
             .samples = image->vk.samples,
             .usage = usage & ~NIL_IMAGE_USAGE_LINEAR_BIT,
+            .compression = false,
          };
          bool ok = nil_image_init(&pdev->info,
                                   &image->linear_tiled_shadow.nil,
@@ -937,6 +940,7 @@ nvk_image_init(struct nvk_device *dev,
          .usage = usage,
          .explicit_row_stride_B = explicit_row_stride_B,
          .max_alignment_B = max_alignment_B,
+         .compression = compression,
       };
    }
 
@@ -977,6 +981,7 @@ nvk_image_init(struct nvk_device *dev,
          .levels = image->vk.mip_levels,
          .samples = image->vk.samples,
          .usage = usage,
+         .compression = compression,
       };
 
       bool ok = nil_image_init(&pdev->info,
-- 
GitLab


From 3174d767c1d9b8cc57c67e6fb96cae9c4ab4fa4b Mon Sep 17 00:00:00 2001
From: Mohamed Ahmed <mohamedahmedegypt2001@gmail.com>
Date: Tue, 22 Jul 2025 21:00:20 +0300
Subject: [PATCH 4/6] nvk: Enable compression

Enables compression for select images. Additionally, we get large (64K), and
huge (2M) pages as a bonus as the hardware can only do compression on these page
sizes. However, due to nouveau limitations, this means that we are limited to
enabling it on things pinned to VRAM. FOrtunately, this works out for us as we
can enable it for color, Z/S, and storage images, which are the main types
to benefit from compression as they're write heavy.

Unfortunately, this means that we need to handle the memory allocation in a
delicate way, as the Vulkan API is a bit restrictive in this regard, so we have
to use dedicated allocations for compression/larger pages.
---
 src/nouveau/vulkan/nvk_device_memory.c | 34 +++++++++++++++----
 src/nouveau/vulkan/nvk_image.c         | 47 +++++++++++++++++++++++---
 2 files changed, 71 insertions(+), 10 deletions(-)

diff --git a/src/nouveau/vulkan/nvk_device_memory.c b/src/nouveau/vulkan/nvk_device_memory.c
index 1712dbae5c0f4..5334c322ef7ea 100644
--- a/src/nouveau/vulkan/nvk_device_memory.c
+++ b/src/nouveau/vulkan/nvk_device_memory.c
@@ -41,11 +41,15 @@ const VkExternalMemoryProperties nvk_dma_buf_mem_props = {
 
 static enum nvkmd_mem_flags
 nvk_memory_type_flags(const VkMemoryType *type,
-                      VkExternalMemoryHandleTypeFlagBits handle_types)
+                      VkExternalMemoryHandleTypeFlagBits handle_types,
+                      bool is_pinned)
 {
    enum nvkmd_mem_flags flags = 0;
    if (type->propertyFlags & VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT)
-      flags = NVKMD_MEM_LOCAL;
+      if (is_pinned)
+         flags = NVKMD_MEM_VRAM;
+      else
+         flags = NVKMD_MEM_LOCAL;
    else
       flags = NVKMD_MEM_GART;
 
@@ -92,7 +96,7 @@ nvk_GetMemoryFdPropertiesKHR(VkDevice device,
    for (unsigned t = 0; t < ARRAY_SIZE(pdev->mem_types); t++) {
       const VkMemoryType *type = &pdev->mem_types[t];
       const enum nvkmd_mem_flags type_flags =
-         nvk_memory_type_flags(type, handleType);
+         nvk_memory_type_flags(type, handleType, false);
 
       /* Flags required to be set on mem to be imported as type
        *
@@ -150,11 +154,12 @@ nvk_AllocateMemory(VkDevice device,
    if (fd_info != NULL)
       handle_types |= fd_info->handleType;
 
-   const enum nvkmd_mem_flags flags = nvk_memory_type_flags(type, handle_types);
+   bool is_pinned = false;
 
+   /* Align to 4K as a start as this works for everything, and then depending on
+    * placement and size, we either keep it as is or increase it to 64K or 2M
+    */
    uint32_t alignment = (1ULL << 12);
-   if (flags & NVKMD_MEM_LOCAL)
-      alignment = (1ULL << 16);
 
    uint8_t pte_kind = 0, tile_mode = 0;
    if (dedicated_info != NULL && dedicated_info->image != VK_NULL_HANDLE) {
@@ -170,9 +175,26 @@ nvk_AllocateMemory(VkDevice device,
          alignment = MAX2(alignment, image->planes[0].nil.align_B);
          pte_kind = image->planes[0].nil.pte_kind;
          tile_mode = image->planes[0].nil.tile_mode;
+      } else if (image->planes->nil.compressed) {
+         /* If it's a dedicated alloc and it's not modifiers, then it's marked
+          * for compression and larger pages, so we set the pinned bit and up
+          * the alignment if the size is >= 2M. For smaller images, we increase
+          * the alignment to 64K later.
+          */
+         is_pinned = true;
+         // Align to 2MiB if size is >= 2MiB
+         // TODO: this breaks somehow with 64K in xonotic (visual gltiches in UI), so right now everything is 2M
+         if (pAllocateInfo->allocationSize % (1ULL << 21))
+            alignment = (1ULL << 21);
       }
    }
 
+   const enum nvkmd_mem_flags flags =
+      nvk_memory_type_flags(type, handle_types, is_pinned);
+   // Align to 64KiB if MEM_VRAM and size is smaller than 2MiB or if MEM_LOCAL
+   if (flags & (NVKMD_MEM_LOCAL | NVKMD_MEM_VRAM))
+      alignment = MAX2(alignment, (1ULL << 16));
+
    const uint64_t aligned_size =
       align64(pAllocateInfo->allocationSize, alignment);
 
diff --git a/src/nouveau/vulkan/nvk_image.c b/src/nouveau/vulkan/nvk_image.c
index 515eaf5139eba..cf4555bcdfeb9 100644
--- a/src/nouveau/vulkan/nvk_image.c
+++ b/src/nouveau/vulkan/nvk_image.c
@@ -775,7 +775,31 @@ nvk_image_init(struct nvk_device *dev,
       image->vk.stencil_usage |= VK_IMAGE_USAGE_SAMPLED_BIT;
    }
 
+   /* To use compression and larger page sizes, we need to signal to the kernel
+    * that the memory requested is going to be VRAM resident. However, this
+    * comes with an issue where said memory can't be evicted to host RAM under
+    * pressure, so we work around this by going with a dedicated allocation for
+    * color, Z/S, and storage image targets which are the main types that would
+    * benefit from compression as they're heavy on writes. Additionally, they
+    * also aren't the majority of memory used, so they can be safely pinned in
+    * VRAM without worrying about eviction under high pressure.
+    * 
+    * We set compression on VkImage creation in order to be able to signal to
+    * NIL that the image will be compressed which would let NIL choose the
+    * ppropriate PTE kinds and minimum alignment, and also to mark the VkImage
+    * as compressed so that in GetImageMemoryRequirements() we are able to
+    * detect it and specify that we need a dedicated allocation for it.
+    * 
+    * We check if the image will be compressed very early on because we need to
+    * enable it for color attachments, and due to VkCmdBlitImage() we smash the
+    * COLOR_ATTACHMENT_BIT early if we detect the TRANSFER_DST_BIT. So we check
+    * for compression before doing that in order to properly single out color.
+    */
    bool compression = false;
+   if (image->vk.usage & (VK_IMAGE_USAGE_STORAGE_BIT |
+       VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT |
+       VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT))
+      compression = true;
 
    if (image->vk.usage & VK_IMAGE_USAGE_TRANSFER_SRC_BIT)
       image->vk.usage |= VK_IMAGE_USAGE_SAMPLED_BIT;
@@ -1008,6 +1032,10 @@ nvk_image_plane_size_align_B(struct nvk_device *dev,
    assert(util_is_power_of_two_or_zero64(plane->nil.align_B));
    if (sparse_bound || plane->nil.pte_kind) {
       *align_B_out = MAX2(plane->nil.align_B, pdev->nvkmd->bind_align_B);
+      // If image is compressed, we increase alignment further to 2M for perf
+      // TODO: this breaks somehow with 64K in xonotic (visual gltiches in UI), so right now everything is 2M
+      if (plane->nil.compressed)
+         *align_B_out = MAX2(*align_B_out, 1ULL << 21);
    } else {
       *align_B_out = plane->nil.align_B;
    }
@@ -1238,10 +1266,21 @@ nvk_get_image_memory_requirements(struct nvk_device *dev,
       switch (ext->sType) {
       case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS: {
          VkMemoryDedicatedRequirements *dedicated = (void *)ext;
-         dedicated->prefersDedicatedAllocation =
-            image->vk.tiling == VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT;
-         dedicated->requiresDedicatedAllocation =
-            image->vk.tiling == VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT;
+         if (image->vk.tiling == VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT ||
+             image->planes[0].nil.compressed) {
+            /* For compression: we need dedicated allocations as compressed
+             * images have to be pinned to VRAM due to nouveau, and we can't
+             * have a separate memory type that's pinned and non evictable due
+             * to the Vulkan API disallowing equivalent image properties
+             * returning different memory types.
+             */
+            dedicated->prefersDedicatedAllocation = true;
+            dedicated->requiresDedicatedAllocation = true;
+
+         } else {
+            dedicated->prefersDedicatedAllocation = false;
+            dedicated->requiresDedicatedAllocation = false;
+         }
          break;
       }
       default:
-- 
GitLab


From 1632f27c9233d0d0fb67c971b85a99abc075352a Mon Sep 17 00:00:00 2001
From: Mohamed Ahmed <mohamedahmedegypt2001@gmail.com>
Date: Wed, 30 Jul 2025 23:34:30 +0300
Subject: [PATCH 5/6] HACK nil: Have different PTE kinds for
 compressed/non-compressed

---
 src/nouveau/nil/image.rs | 7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)

diff --git a/src/nouveau/nil/image.rs b/src/nouveau/nil/image.rs
index 01948c74e6914..70feeaa3796f3 100644
--- a/src/nouveau/nil/image.rs
+++ b/src/nouveau/nil/image.rs
@@ -185,6 +185,7 @@ pub struct Image {
     pub compressed: bool,
     pub tile_mode: u16,
     pub pte_kind: u8,
+    pub compressed_pte_kind: u8,
 }
 
 impl Image {
@@ -286,6 +287,7 @@ impl Image {
             compressed: false,
             tile_mode: 0,
             pte_kind: 0,
+            compressed_pte_kind: 0,
             mip_tail_first_lod: 0,
         };
         image.levels[0] = level0;
@@ -370,6 +372,7 @@ impl Image {
             compressed: info.compression,
             tile_mode: 0,
             pte_kind: 0,
+            compressed_pte_kind: 0,
             mip_tail_first_lod: 0,
         };
 
@@ -433,7 +436,9 @@ impl Image {
             image.align_B = std::cmp::max(image.align_B, 1 << 16);
         }
 
-        image.pte_kind = Self::choose_pte_kind(
+        image.pte_kind =
+            Self::choose_pte_kind(dev, info.format, info.samples, false);
+        image.compressed_pte_kind = Self::choose_pte_kind(
             dev,
             info.format,
             info.samples,
-- 
GitLab


From 1500e1f936485a722740ab24b48a7eb99e84a65c Mon Sep 17 00:00:00 2001
From: Mohamed Ahmed <mohamedahmedegypt2001@gmail.com>
Date: Wed, 30 Jul 2025 23:35:00 +0300
Subject: [PATCH 6/6] HACK nvk: Switch PTE kind to compressed one at bind time
 when we know for sure that it'll be pinned to VRAM

---
 src/nouveau/vulkan/nvk_image.c | 10 ++++++++++
 1 file changed, 10 insertions(+)

diff --git a/src/nouveau/vulkan/nvk_image.c b/src/nouveau/vulkan/nvk_image.c
index cf4555bcdfeb9..bdc7589230003 100644
--- a/src/nouveau/vulkan/nvk_image.c
+++ b/src/nouveau/vulkan/nvk_image.c
@@ -1521,6 +1521,16 @@ nvk_image_plane_bind(struct nvk_device *dev,
    *offset_B = align64(*offset_B, plane_align_B);
 
    if (plane->va != NULL) {
+      // TODO: do this in a less hacky way
+      /* We know here whether the image will be in sysmem or not. By default,
+       * everything uses non-compressed PTE kinds, which means comp is off.
+       * However, if we know that it'll be pinned to VRAM, we switch the kind
+       * to the compressed one, which enables comp for stuff pinned to VRAM.
+       */
+      if (mem->mem->flags & NVKMD_MEM_VRAM) {
+         plane->va->pte_kind = plane->nil.compressed_pte_kind;
+      } 
+
       VkResult result = nvkmd_va_bind_mem(plane->va, &image->vk.base, 0,
                                           mem->mem, *offset_B,
                                           plane->va->size_B);
-- 
GitLab

