From 5b455e7b8dc020c6803b5ae44797fb2083413c3a Mon Sep 17 00:00:00 2001
From: Mohamed Ahmed <mohamedahmedegypt2001@gmail.com>
Date: Tue, 22 Jul 2025 21:01:01 +0300
Subject: [PATCH 1/6] nvk/nvkmd: Fix alignments

Previously, there was some mixing up of alignments between the alignment
provided by the caller, and the minimum alignment we have (4KiB). Additionally,
there was some redundant aligning being done to data already passed in aligned.
This didn't matter because we were always using 4K pages anyways due to kernel
limitations. However, this now needs fixing to allow for larger page support.
---
 .../vulkan/nvkmd/nouveau/nvkmd_nouveau_mem.c  | 22 ++++++++++++++-----
 .../vulkan/nvkmd/nouveau/nvkmd_nouveau_va.c   | 10 ++++++---
 2 files changed, 23 insertions(+), 9 deletions(-)

diff --git a/src/nouveau/vulkan/nvkmd/nouveau/nvkmd_nouveau_mem.c b/src/nouveau/vulkan/nvkmd/nouveau/nvkmd_nouveau_mem.c
index 4c93e25fe3d42..96e3959da6b5b 100644
--- a/src/nouveau/vulkan/nvkmd/nouveau/nvkmd_nouveau_mem.c
+++ b/src/nouveau/vulkan/nvkmd/nouveau/nvkmd_nouveau_mem.c
@@ -40,8 +40,14 @@ create_mem_or_close_bo(struct nvkmd_nouveau_dev *dev,
       goto fail_bo;
    }
 
+   /* If the bo is VRAM pinned, we should use the VA alignment as it's larger
+    * and has compression, thus allowing for higher perf. Otherwise, for GART
+    * we stick to 4K alignment as that's required for system RAM.
+    */
+   uint32_t mem_bind_align_B = (mem_flags & NVKMD_MEM_VRAM) ? va_align_B :
+                               dev->base.pdev->bind_align_B;
    nvkmd_mem_init(&dev->base, &mem->base, &nvkmd_nouveau_mem_ops,
-                  mem_flags, size_B, dev->base.pdev->bind_align_B);
+                  mem_flags, size_B, mem_bind_align_B);
    mem->bo = bo;
 
    result = nvkmd_dev_alloc_va(&dev->base, log_obj,
@@ -122,11 +128,15 @@ nvkmd_nouveau_alloc_tiled_mem(struct nvkmd_dev *_dev,
    if (force_mem_to_gart(dev->base.pdev, flags))
       domains = NOUVEAU_WS_BO_GART;
 
-   const uint32_t mem_align_B = _dev->pdev->bind_align_B;
-   size_B = align64(size_B, mem_align_B);
-
+   /* There's no need to align again because the size we get from the callers
+    * is already aligned. However, just in case, add in a minimum of alignment
+    * of 4KiB, and also if not aligned, ensure that the size is aligned.
+    */
+   const uint32_t min_align_B = _dev->pdev->bind_align_B;
    assert(util_is_power_of_two_or_zero64(align_B));
-   const uint64_t va_align_B = MAX2(mem_align_B, align_B);
+   const uint64_t va_align_B = MAX2(min_align_B, align_B);
+   if (size_B % va_align_B != 0)
+      size_B = align64(size_B, va_align_B);
 
    enum nouveau_ws_bo_flags nouveau_flags = domains;
    if (flags & NVKMD_MEM_CAN_MAP)
@@ -135,7 +145,7 @@ nvkmd_nouveau_alloc_tiled_mem(struct nvkmd_dev *_dev,
       nouveau_flags |= NOUVEAU_WS_BO_NO_SHARE;
 
    struct nouveau_ws_bo *bo = nouveau_ws_bo_new_tiled(dev->ws_dev,
-                                                      size_B, mem_align_B,
+                                                      size_B, va_align_B,
                                                       pte_kind, tile_mode,
                                                       nouveau_flags);
    if (bo == NULL)
diff --git a/src/nouveau/vulkan/nvkmd/nouveau/nvkmd_nouveau_va.c b/src/nouveau/vulkan/nvkmd/nouveau/nvkmd_nouveau_va.c
index 922215d88898f..539e5d31d5110 100644
--- a/src/nouveau/vulkan/nvkmd/nouveau/nvkmd_nouveau_va.c
+++ b/src/nouveau/vulkan/nvkmd/nouveau/nvkmd_nouveau_va.c
@@ -125,12 +125,16 @@ nvkmd_nouveau_alloc_va(struct nvkmd_dev *_dev,
    if (va == NULL)
       return vk_error(log_obj, VK_ERROR_OUT_OF_HOST_MEMORY);
 
+   /* There's no need to align again because the size we get from the callers
+    * is already aligned. However, just in case, add in a minimum of alignment
+    * of 4KiB, and also if not aligned, ensure that the size is aligned.
+    */
    const uint32_t min_align_B = _dev->pdev->bind_align_B;
-   size_B = align64(size_B, min_align_B);
-
    assert(util_is_power_of_two_or_zero64(align_B));
    align_B = MAX2(align_B, min_align_B);
-
+   if (size_B % align_B != 0)
+      size_B = align64(size_B, align_B);
+   
    assert((fixed_addr == 0) == !(flags & NVKMD_VA_ALLOC_FIXED));
 
    result = alloc_heap_addr(dev, log_obj, flags, size_B, align_B,
-- 
GitLab


From ba404f8d7732d35c2aaf44051d35eaa26df1e5f2 Mon Sep 17 00:00:00 2001
From: Mohamed Ahmed <mohamedahmedegypt2001@gmail.com>
Date: Tue, 29 Jul 2025 19:41:21 +0300
Subject: [PATCH 2/6] nil: Add missing compressible PTE kinds

We were missing compressible PTE kinds for generic on TU102 and GB202. Adds them
---
 src/nouveau/nil/image.rs | 21 ++++++++++++++++++---
 1 file changed, 18 insertions(+), 3 deletions(-)

diff --git a/src/nouveau/nil/image.rs b/src/nouveau/nil/image.rs
index 0643720817eeb..feb2fdb629ccc 100644
--- a/src/nouveau/nil/image.rs
+++ b/src/nouveau/nil/image.rs
@@ -753,8 +753,11 @@ impl Image {
         }
     }
 
-    fn gb202_choose_pte_kind(_format: Format, _compressed: bool) -> u8 {
+    fn gb202_choose_pte_kind(_format: Format, compressed: bool) -> u8 {
         use nvidia_headers::hwref::tu102::mmu::*;
+        if compressed {
+            return NV_MMU_PTE_KIND_GENERIC_MEMORY_COMPRESSIBLE_DISABLE_PLC.try_into().unwrap();
+        }
         return NV_MMU_PTE_KIND_GENERIC_MEMORY.try_into().unwrap();
     }
 
@@ -793,7 +796,13 @@ impl Image {
                     NV_MMU_PTE_KIND_ZF32_X24S8
                 }
             }
-            PIPE_FORMAT_Z32_FLOAT => NV_MMU_PTE_KIND_GENERIC_MEMORY,
+            PIPE_FORMAT_Z32_FLOAT => { 
+                if compressed {
+                    NV_MMU_PTE_KIND_GENERIC_MEMORY_COMPRESSIBLE_DISABLE_PLC
+                } else {
+                    NV_MMU_PTE_KIND_GENERIC_MEMORY
+                }
+            }
             PIPE_FORMAT_S8_UINT => {
                 if compressed {
                     NV_MMU_PTE_KIND_S8_COMPRESSIBLE_DISABLE_PLC
@@ -801,7 +810,13 @@ impl Image {
                     NV_MMU_PTE_KIND_S8
                 }
             }
-            _ => NV_MMU_PTE_KIND_GENERIC_MEMORY,
+            _ => { 
+                if compressed {
+                    NV_MMU_PTE_KIND_GENERIC_MEMORY_COMPRESSIBLE_DISABLE_PLC
+                } else {
+                    NV_MMU_PTE_KIND_GENERIC_MEMORY
+                }
+            }
         }
         .try_into()
         .unwrap()
-- 
GitLab


From 892410f96c5d2fda8cf2b8fcdc0d2a1c0ad6d670 Mon Sep 17 00:00:00 2001
From: Mohamed Ahmed <mohamedahmedegypt2001@gmail.com>
Date: Tue, 29 Jul 2025 19:56:23 +0300
Subject: [PATCH 3/6] nil, nvk: Add plumbing for compression

This lays the groundwork for enabling compression by adding a way to pass in
whether the image will be compressed or not from NVK to NIL.
---
 src/nouveau/nil/image.rs       | 8 ++++++--
 src/nouveau/vulkan/nvk_image.c | 5 +++++
 2 files changed, 11 insertions(+), 2 deletions(-)

diff --git a/src/nouveau/nil/image.rs b/src/nouveau/nil/image.rs
index feb2fdb629ccc..1cec2a506e62f 100644
--- a/src/nouveau/nil/image.rs
+++ b/src/nouveau/nil/image.rs
@@ -157,6 +157,7 @@ pub struct ImageInitInfo {
     pub modifier: u64,
     pub explicit_row_stride_B: u32,
     pub max_alignment_B: u32,
+    pub compression: bool,
 }
 
 /// Represents the data layout of a single slice (level + lod) of an image.
@@ -366,7 +367,7 @@ impl Image {
             array_stride_B: 0,
             align_B: 0,
             size_B: 0,
-            compressed: false,
+            compressed: info.compression,
             tile_mode: 0,
             pte_kind: 0,
             mip_tail_first_lod: 0,
@@ -448,7 +449,10 @@ impl Image {
             | (u16::from(image.levels[0].tiling.z_log2) << 8);
 
         image.align_B = std::cmp::max(image.align_B, 4096);
-        if image.pte_kind >= 0xb && image.pte_kind <= 0xe {
+        if image.pte_kind >= 0x8 && image.pte_kind <= 0xe {
+            // If the image is compressed, set minimum alignment to 64K.
+            // NVK may increase this to 2M for perf.
+            assert!(image.compressed);
             image.align_B = std::cmp::max(image.align_B, 1 << 16);
         }
 
diff --git a/src/nouveau/vulkan/nvk_image.c b/src/nouveau/vulkan/nvk_image.c
index 73bc9594c4476..5bef2e79735a2 100644
--- a/src/nouveau/vulkan/nvk_image.c
+++ b/src/nouveau/vulkan/nvk_image.c
@@ -775,6 +775,8 @@ nvk_image_init(struct nvk_device *dev,
       image->vk.stencil_usage |= VK_IMAGE_USAGE_SAMPLED_BIT;
    }
 
+   bool compression = false;
+
    if (image->vk.usage & VK_IMAGE_USAGE_TRANSFER_SRC_BIT)
       image->vk.usage |= VK_IMAGE_USAGE_SAMPLED_BIT;
    if (image->vk.usage & VK_IMAGE_USAGE_TRANSFER_DST_BIT)
@@ -889,6 +891,7 @@ nvk_image_init(struct nvk_device *dev,
             .levels = image->vk.mip_levels,
             .samples = image->vk.samples,
             .usage = usage & ~NIL_IMAGE_USAGE_LINEAR_BIT,
+            .compression = false,
          };
          bool ok = nil_image_init(&pdev->info,
                                   &image->linear_tiled_shadow.nil,
@@ -937,6 +940,7 @@ nvk_image_init(struct nvk_device *dev,
          .usage = usage,
          .explicit_row_stride_B = explicit_row_stride_B,
          .max_alignment_B = max_alignment_B,
+         .compression = compression,
       };
    }
 
@@ -977,6 +981,7 @@ nvk_image_init(struct nvk_device *dev,
          .levels = image->vk.mip_levels,
          .samples = image->vk.samples,
          .usage = usage,
+         .compression = compression,
       };
 
       bool ok = nil_image_init(&pdev->info,
-- 
GitLab


From 371f3d684f4162764b263e05b2cb9461c744c9d5 Mon Sep 17 00:00:00 2001
From: Mohamed Ahmed <mohamedahmedegypt2001@gmail.com>
Date: Tue, 22 Jul 2025 21:00:20 +0300
Subject: [PATCH 4/6] nvk: Enable compression

Enables compression for select images. Additionally, we get large (64K), and
huge (2M) pages as a bonus as the hardware can only do compression on these page
sizes. However, due to nouveau limitations, this means that we are limited to
enabling it on things pinned to VRAM. FOrtunately, this works out for us as we
can enable it for color, Z/S, and storage images, which are the main types
to benefit from compression as they're write heavy.

Unfortunately, this means that we need to handle the memory allocation in a
delicate way, as the Vulkan API is a bit restrictive in this regard, so we have
to use dedicated allocations for compression/larger pages.
---
 src/nouveau/vulkan/nvk_device_memory.c | 34 +++++++++++++++----
 src/nouveau/vulkan/nvk_image.c         | 47 +++++++++++++++++++++++---
 2 files changed, 71 insertions(+), 10 deletions(-)

diff --git a/src/nouveau/vulkan/nvk_device_memory.c b/src/nouveau/vulkan/nvk_device_memory.c
index 19a127a64ed92..6e15a94936829 100644
--- a/src/nouveau/vulkan/nvk_device_memory.c
+++ b/src/nouveau/vulkan/nvk_device_memory.c
@@ -41,11 +41,15 @@ const VkExternalMemoryProperties nvk_dma_buf_mem_props = {
 
 static enum nvkmd_mem_flags
 nvk_memory_type_flags(const VkMemoryType *type,
-                      VkExternalMemoryHandleTypeFlagBits handle_types)
+                      VkExternalMemoryHandleTypeFlagBits handle_types,
+                      bool is_pinned)
 {
    enum nvkmd_mem_flags flags = 0;
    if (type->propertyFlags & VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT)
-      flags = NVKMD_MEM_LOCAL;
+      if (is_pinned)
+         flags = NVKMD_MEM_VRAM;
+      else
+         flags = NVKMD_MEM_LOCAL;
    else
       flags = NVKMD_MEM_GART;
 
@@ -92,7 +96,7 @@ nvk_GetMemoryFdPropertiesKHR(VkDevice device,
    for (unsigned t = 0; t < ARRAY_SIZE(pdev->mem_types); t++) {
       const VkMemoryType *type = &pdev->mem_types[t];
       const enum nvkmd_mem_flags type_flags =
-         nvk_memory_type_flags(type, handleType);
+         nvk_memory_type_flags(type, handleType, false);
 
       /* Flags required to be set on mem to be imported as type
        *
@@ -145,11 +149,12 @@ nvk_AllocateMemory(VkDevice device,
    if (fd_info != NULL)
       handle_types |= fd_info->handleType;
 
-   const enum nvkmd_mem_flags flags = nvk_memory_type_flags(type, handle_types);
+   bool is_pinned = false;
 
+   /* Align to 4K as a start as this works for everything, and then depending on
+    * placement and size, we either keep it as is or increase it to 64K or 2M
+    */
    uint32_t alignment = (1ULL << 12);
-   if (flags & NVKMD_MEM_LOCAL)
-      alignment = (1ULL << 16);
 
    uint8_t pte_kind = 0, tile_mode = 0;
    if (dedicated_info != NULL) {
@@ -163,9 +168,26 @@ nvk_AllocateMemory(VkDevice device,
          alignment = MAX2(alignment, image->planes[0].nil.align_B);
          pte_kind = image->planes[0].nil.pte_kind;
          tile_mode = image->planes[0].nil.tile_mode;
+      } else if (image != NULL && image->planes->nil.compressed) {
+         /* If it's a dedicated alloc and it's not modifiers, then it's marked
+          * for compression and larger pages, so we set the pinned bit and up
+          * the alignment if the size is >= 2M. For smaller images, we increase
+          * the alignment to 64K later.
+          */
+         is_pinned = true;
+         // Align to 2MiB if size is >= 2MiB
+         // TODO: this breaks somehow with 64K in xonotic (visual gltiches in UI), so right now everything is 2M
+         if (pAllocateInfo->allocationSize % (1ULL << 21))
+            alignment = (1ULL << 21);
       }
    }
 
+   const enum nvkmd_mem_flags flags =
+      nvk_memory_type_flags(type, handle_types, is_pinned);
+   // Align to 64KiB if MEM_VRAM and size is smaller than 2MiB or if MEM_LOCAL
+   if (flags & (NVKMD_MEM_LOCAL | NVKMD_MEM_VRAM))
+      alignment = MAX2(alignment, (1ULL << 16));
+
    const uint64_t aligned_size =
       align64(pAllocateInfo->allocationSize, alignment);
 
diff --git a/src/nouveau/vulkan/nvk_image.c b/src/nouveau/vulkan/nvk_image.c
index 5bef2e79735a2..9157409048ae5 100644
--- a/src/nouveau/vulkan/nvk_image.c
+++ b/src/nouveau/vulkan/nvk_image.c
@@ -775,7 +775,31 @@ nvk_image_init(struct nvk_device *dev,
       image->vk.stencil_usage |= VK_IMAGE_USAGE_SAMPLED_BIT;
    }
 
+   /* To use compression and larger page sizes, we need to signal to the kernel
+    * that the memory requested is going to be VRAM resident. However, this
+    * comes with an issue where said memory can't be evicted to host RAM under
+    * pressure, so we work around this by going with a dedicated allocation for
+    * color, Z/S, and storage image targets which are the main types that would
+    * benefit from compression as they're heavy on writes. Additionally, they
+    * also aren't the majority of memory used, so they can be safely pinned in
+    * VRAM without worrying about eviction under high pressure.
+    * 
+    * We set compression on VkImage creation in order to be able to signal to
+    * NIL that the image will be compressed which would let NIL choose the
+    * ppropriate PTE kinds and minimum alignment, and also to mark the VkImage
+    * as compressed so that in GetImageMemoryRequirements() we are able to
+    * detect it and specify that we need a dedicated allocation for it.
+    * 
+    * We check if the image will be compressed very early on because we need to
+    * enable it for color attachments, and due to VkCmdBlitImage() we smash the
+    * COLOR_ATTACHMENT_BIT early if we detect the TRANSFER_DST_BIT. So we check
+    * for compression before doing that in order to properly single out color.
+    */
    bool compression = false;
+   if (image->vk.usage & (VK_IMAGE_USAGE_STORAGE_BIT |
+       VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT |
+       VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT))
+      compression = true;
 
    if (image->vk.usage & VK_IMAGE_USAGE_TRANSFER_SRC_BIT)
       image->vk.usage |= VK_IMAGE_USAGE_SAMPLED_BIT;
@@ -1008,6 +1032,10 @@ nvk_image_plane_size_align_B(struct nvk_device *dev,
    assert(util_is_power_of_two_or_zero64(plane->nil.align_B));
    if (sparse_bound || plane->nil.pte_kind) {
       *align_B_out = MAX2(plane->nil.align_B, pdev->nvkmd->bind_align_B);
+      // If image is compressed, we increase alignment further to 2M for perf
+      // TODO: this breaks somehow with 64K in xonotic (visual gltiches in UI), so right now everything is 2M
+      if (plane->nil.compressed)
+         *align_B_out = MAX2(*align_B_out, 1ULL << 21);
    } else {
       *align_B_out = plane->nil.align_B;
    }
@@ -1244,10 +1272,21 @@ nvk_get_image_memory_requirements(struct nvk_device *dev,
       switch (ext->sType) {
       case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS: {
          VkMemoryDedicatedRequirements *dedicated = (void *)ext;
-         dedicated->prefersDedicatedAllocation =
-            image->vk.tiling == VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT;
-         dedicated->requiresDedicatedAllocation =
-            image->vk.tiling == VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT;
+         if (image->vk.tiling == VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT ||
+             image->planes[0].nil.compressed) {
+            /* For compression: we need dedicated allocations as compressed
+             * images have to be pinned to VRAM due to nouveau, and we can't
+             * have a separate memory type that's pinned and non evictable due
+             * to the Vulkan API disallowing equivalent image properties
+             * returning different memory types.
+             */
+            dedicated->prefersDedicatedAllocation = true;
+            dedicated->requiresDedicatedAllocation = true;
+
+         } else {
+            dedicated->prefersDedicatedAllocation = false;
+            dedicated->requiresDedicatedAllocation = false;
+         }
          break;
       }
       default:
-- 
GitLab


From cac33a46e5bdaecc966b5129969385b8c3266861 Mon Sep 17 00:00:00 2001
From: Mohamed Ahmed <mohamedahmedegypt2001@gmail.com>
Date: Wed, 30 Jul 2025 23:34:30 +0300
Subject: [PATCH 5/6] HACK nil: Have different PTE kinds for
 compressed/non-compressed

---
 src/nouveau/nil/image.rs | 11 ++++++++++-
 1 file changed, 10 insertions(+), 1 deletion(-)

diff --git a/src/nouveau/nil/image.rs b/src/nouveau/nil/image.rs
index 1cec2a506e62f..418e3fb7fe11f 100644
--- a/src/nouveau/nil/image.rs
+++ b/src/nouveau/nil/image.rs
@@ -185,6 +185,7 @@ pub struct Image {
     pub compressed: bool,
     pub tile_mode: u16,
     pub pte_kind: u8,
+    pub compressed_pte_kind: u8,
 }
 
 impl Image {
@@ -286,6 +287,7 @@ impl Image {
             compressed: false,
             tile_mode: 0,
             pte_kind: 0,
+            compressed_pte_kind: 0,
             mip_tail_first_lod: 0,
         };
         image.levels[0] = level0;
@@ -370,6 +372,7 @@ impl Image {
             compressed: info.compression,
             tile_mode: 0,
             pte_kind: 0,
+            compressed_pte_kind: 0,
             mip_tail_first_lod: 0,
         };
 
@@ -434,6 +437,12 @@ impl Image {
         }
 
         image.pte_kind = Self::choose_pte_kind(
+            dev,
+            info.format,
+            info.samples,
+            false,
+        );
+        image.compressed_pte_kind = Self::choose_pte_kind(
             dev,
             info.format,
             info.samples,
@@ -449,7 +458,7 @@ impl Image {
             | (u16::from(image.levels[0].tiling.z_log2) << 8);
 
         image.align_B = std::cmp::max(image.align_B, 4096);
-        if image.pte_kind >= 0x8 && image.pte_kind <= 0xe {
+        if image.compressed_pte_kind >= 0x8 && image.compressed_pte_kind <= 0xe {
             // If the image is compressed, set minimum alignment to 64K.
             // NVK may increase this to 2M for perf.
             assert!(image.compressed);
-- 
GitLab


From 6ffbd46c4f7a2d4d76d63bc82cddfbb5ab101d9c Mon Sep 17 00:00:00 2001
From: Mohamed Ahmed <mohamedahmedegypt2001@gmail.com>
Date: Wed, 30 Jul 2025 23:35:00 +0300
Subject: [PATCH 6/6] HACK nvk: Switch PTE kind to compressed one at bind time
 when we know for sure that it'll be pinned to VRAM

---
 src/nouveau/vulkan/nvk_image.c | 10 ++++++++++
 1 file changed, 10 insertions(+)

diff --git a/src/nouveau/vulkan/nvk_image.c b/src/nouveau/vulkan/nvk_image.c
index 9157409048ae5..eb5930f2fc123 100644
--- a/src/nouveau/vulkan/nvk_image.c
+++ b/src/nouveau/vulkan/nvk_image.c
@@ -1527,6 +1527,16 @@ nvk_image_plane_bind(struct nvk_device *dev,
    *offset_B = align64(*offset_B, plane_align_B);
 
    if (plane->va != NULL) {
+      // TODO: do this in a less hacky way
+      /* We know here whether the image will be in sysmem or not. By default,
+       * everything uses non-compressed PTE kinds, which means comp is off.
+       * However, if we know that it'll be pinned to VRAM, we switch the kind
+       * to the compressed one, which enables comp for stuff pinned to VRAM.
+       */
+      if (mem->mem->flags & NVKMD_MEM_VRAM) {
+         plane->va->pte_kind = plane->nil.compressed_pte_kind;
+      } 
+
       VkResult result = nvkmd_va_bind_mem(plane->va, &image->vk.base, 0,
                                           mem->mem, *offset_B,
                                           plane->va->size_B);
-- 
GitLab

