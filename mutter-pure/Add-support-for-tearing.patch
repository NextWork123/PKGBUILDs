From ac6f8aeb6b04d5163fe5438af364683c8f54ce3e Mon Sep 17 00:00:00 2001
From: Naveen Kumar <naveen1.kumar@intel.com>
Date: Mon, 26 May 2025 14:55:01 +0000
Subject: [PATCH 1/7] build: Bump libdrm requirement to >= 2.4.120

Signed-off-by: Vasiliy Stelmachenok <ventureo@cachyos.org>
---
 meson.build | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/meson.build b/meson.build
index b689060301..164064025c 100644
--- a/meson.build
+++ b/meson.build
@@ -52,7 +52,7 @@ wayland_protocols_req = '>= 1.41'
 # native backend version requirements
 libinput_req = '>= 1.27.0'
 gbm_req = '>= 21.3'
-libdrm_req = '>= 2.4.118'
+libdrm_req = '>= 2.4.120'
 
 # screen cast version requirements
 libpipewire_req = '>= 1.2.0'
-- 
2.50.1


From 6a630c7f2e4ad232692aa3ac330d24a56149f6a5 Mon Sep 17 00:00:00 2001
From: Naveen Kumar <naveen1.kumar@intel.com>
Date: Thu, 10 Apr 2025 04:27:46 +0000
Subject: [PATCH 2/7] atomic: Check for atomic tearing capability

Verify if the DRM device supports atomic async page flips.

Signed-off-by: Vasiliy Stelmachenok <ventureo@cachyos.org>
---
 src/backends/native/meta-kms-device.c      | 6 ++++++
 src/backends/native/meta-kms-device.h      | 3 +++
 src/backends/native/meta-kms-impl-device.c | 6 ++++++
 src/backends/native/meta-kms-impl-device.h | 1 +
 4 files changed, 16 insertions(+)

diff --git a/src/backends/native/meta-kms-device.c b/src/backends/native/meta-kms-device.c
index 4dec048d08..0ce4ccd0bd 100644
--- a/src/backends/native/meta-kms-device.c
+++ b/src/backends/native/meta-kms-device.c
@@ -140,6 +140,12 @@ meta_kms_device_uses_monotonic_clock (MetaKmsDevice *device)
   return device->caps.uses_monotonic_clock;
 }
 
+gboolean
+meta_kms_device_supports_async_page_flip (MetaKmsDevice *device)
+{
+  return device->caps.supports_async_page_flip;
+}
+
 GList *
 meta_kms_device_get_connectors (MetaKmsDevice *device)
 {
diff --git a/src/backends/native/meta-kms-device.h b/src/backends/native/meta-kms-device.h
index 6dfa5a76ac..49d68b19c0 100644
--- a/src/backends/native/meta-kms-device.h
+++ b/src/backends/native/meta-kms-device.h
@@ -51,6 +51,9 @@ gboolean meta_kms_device_prefers_shadow_buffer (MetaKmsDevice *device);
 META_EXPORT_TEST
 gboolean meta_kms_device_uses_monotonic_clock (MetaKmsDevice *device);
 
+META_EXPORT_TEST
+gboolean meta_kms_device_supports_async_page_flip (MetaKmsDevice *device);
+
 META_EXPORT_TEST
 GList * meta_kms_device_get_connectors (MetaKmsDevice *device);
 
diff --git a/src/backends/native/meta-kms-impl-device.c b/src/backends/native/meta-kms-impl-device.c
index c265e6e972..ce67724ce5 100644
--- a/src/backends/native/meta-kms-impl-device.c
+++ b/src/backends/native/meta-kms-impl-device.c
@@ -558,6 +558,7 @@ init_caps (MetaKmsImplDevice *impl_device)
   uint64_t prefer_shadow;
   uint64_t uses_monotonic_clock;
   uint64_t addfb2_modifiers;
+  uint64_t async_page_flip_supported;
 
   fd = meta_device_file_get_fd (priv->device_file);
   if (drmGetCap (fd, DRM_CAP_CURSOR_WIDTH, &cursor_width) == 0 &&
@@ -585,6 +586,11 @@ init_caps (MetaKmsImplDevice *impl_device)
     {
       priv->caps.addfb2_modifiers = (addfb2_modifiers != 0);
     }
+
+  if (drmGetCap (fd, DRM_CAP_ATOMIC_ASYNC_PAGE_FLIP, &async_page_flip_supported) == 0)
+    {
+      priv->caps.supports_async_page_flip = (async_page_flip_supported != 0);
+    }
 }
 
 static void
diff --git a/src/backends/native/meta-kms-impl-device.h b/src/backends/native/meta-kms-impl-device.h
index 22396dba68..20eb5d1e62 100644
--- a/src/backends/native/meta-kms-impl-device.h
+++ b/src/backends/native/meta-kms-impl-device.h
@@ -39,6 +39,7 @@ typedef struct _MetaKmsDeviceCaps
   gboolean uses_monotonic_clock;
   gboolean addfb2_modifiers;
   gboolean supports_color_modes;
+  gboolean supports_async_page_flip;
 } MetaKmsDeviceCaps;
 
 
-- 
2.50.1


From 41be4a9096d4e2cc16c6df18f4497405730472e8 Mon Sep 17 00:00:00 2001
From: Naveen Kumar <naveen1.kumar@intel.com>
Date: Mon, 14 Oct 2024 08:26:52 +0000
Subject: [PATCH 3/7] settings: Add experimental feature for tearing

Introduce an experimental feature for tearing, which can be
enabled by adding the "tearing" keyword under the "experimental-features"
GSetting. This requirement will be removed once the tearing design
is approved for general use and adequately addresses all common
use cases.

Signed-off-by: Vasiliy Stelmachenok <ventureo@cachyos.org>
---
 data/org.gnome.mutter.gschema.xml.in       | 7 +++++++
 src/backends/meta-settings-private.h       | 1 +
 src/backends/meta-settings.c               | 3 +++
 src/backends/native/meta-onscreen-native.c | 9 +++++++++
 4 files changed, 20 insertions(+)

diff --git a/data/org.gnome.mutter.gschema.xml.in b/data/org.gnome.mutter.gschema.xml.in
index 3a8fd2bc31..4187fb0a79 100644
--- a/data/org.gnome.mutter.gschema.xml.in
+++ b/data/org.gnome.mutter.gschema.xml.in
@@ -6,6 +6,7 @@
     <value nick="autoclose-xwayland" value="4"/>
     <value nick="variable-refresh-rate" value="8"/>
     <value nick="xwayland-native-scaling" value="16"/>
+    <value nick="tearing" value="32"/>
   </flags>
 
   <schema id="org.gnome.mutter" path="/org/gnome/mutter/"
@@ -143,6 +144,12 @@
                                         be unscaled. Setting only takes effect
                                         when “scale-monitor-framebuffer” is
                                         enabled as well.
+
+        • “tearing”                   — makes mutter change the presentation
+                                        to Async or Vsync when applicable and if
+                                        supported by the driver, Configurable in
+                                        Settings. Requires a restart.
+
       </description>
     </key>
 
diff --git a/src/backends/meta-settings-private.h b/src/backends/meta-settings-private.h
index 0a6a92c7b9..ddf9fc2e60 100644
--- a/src/backends/meta-settings-private.h
+++ b/src/backends/meta-settings-private.h
@@ -34,6 +34,7 @@ typedef enum _MetaExperimentalFeature
   META_EXPERIMENTAL_FEATURE_AUTOCLOSE_XWAYLAND  = (1 << 2),
   META_EXPERIMENTAL_FEATURE_VARIABLE_REFRESH_RATE = (1 << 3),
   META_EXPERIMENTAL_FEATURE_XWAYLAND_NATIVE_SCALING  = (1 << 4),
+  META_EXPERIMENTAL_FEATURE_TEARING = (1 << 5),
 } MetaExperimentalFeature;
 
 typedef enum _MetaXwaylandExtension
diff --git a/src/backends/meta-settings.c b/src/backends/meta-settings.c
index f8353cb625..9f0b786bff 100644
--- a/src/backends/meta-settings.c
+++ b/src/backends/meta-settings.c
@@ -50,6 +50,7 @@ static GDebugKey experimental_feature_keys[] = {
   { "autoclose-xwayland", META_EXPERIMENTAL_FEATURE_AUTOCLOSE_XWAYLAND },
   { "variable-refresh-rate", META_EXPERIMENTAL_FEATURE_VARIABLE_REFRESH_RATE },
   { "xwayland-native-scaling", META_EXPERIMENTAL_FEATURE_XWAYLAND_NATIVE_SCALING },
+  { "tearing", META_EXPERIMENTAL_FEATURE_TEARING },
 };
 
 static guint signals[N_SIGNALS];
@@ -313,6 +314,8 @@ experimental_features_handler (GVariant *features_variant,
         feature = META_EXPERIMENTAL_FEATURE_VARIABLE_REFRESH_RATE;
       else if (g_str_equal (feature_str, "xwayland-native-scaling"))
         feature = META_EXPERIMENTAL_FEATURE_XWAYLAND_NATIVE_SCALING;
+      else if (g_str_equal (feature_str, "tearing"))
+        feature = META_EXPERIMENTAL_FEATURE_TEARING;
 
       if (feature)
         g_message ("Enabling experimental feature '%s'", feature_str);
diff --git a/src/backends/native/meta-onscreen-native.c b/src/backends/native/meta-onscreen-native.c
index 95f7ec3d09..48ae12894c 100644
--- a/src/backends/native/meta-onscreen-native.c
+++ b/src/backends/native/meta-onscreen-native.c
@@ -126,6 +126,8 @@ struct _MetaOnscreenNative
   gboolean frame_sync_requested;
   gboolean frame_sync_enabled;
 
+  gboolean is_tearing_allowed;
+
   MetaRendererView *view;
 
   union {
@@ -2979,6 +2981,9 @@ meta_onscreen_native_new (MetaRendererNative *renderer_native,
                           int                 height)
 {
   MetaOnscreenNative *onscreen_native;
+  MetaRenderer *renderer = META_RENDERER (renderer_native);
+  MetaBackend *backend = meta_renderer_get_backend (renderer);
+  MetaSettings *settings = meta_backend_get_settings (backend);
   CoglFramebufferDriverConfig driver_config;
   const MetaOutputInfo *output_info = meta_output_get_info (output);
 
@@ -3016,6 +3021,10 @@ meta_onscreen_native_new (MetaRendererNative *renderer_native,
                           onscreen_native);
     }
 
+  onscreen_native->is_tearing_allowed =
+    meta_settings_is_experimental_feature_enabled (
+      settings, META_EXPERIMENTAL_FEATURE_TEARING);
+
   return onscreen_native;
 }
 
-- 
2.50.1


From 4e89c8c5e3d6d6bb9d3c78e7f2d78548e66d39ba Mon Sep 17 00:00:00 2001
From: Naveen Kumar <naveen1.kumar@intel.com>
Date: Mon, 26 May 2025 15:02:14 +0000
Subject: [PATCH 4/7] wayland: Add support for tearing control protocol

Implement core support for the Wayland tearing control protocol,
enabling Wayland clients to request tearing or asynchronous page
flip functionality.

Signed-off-by: Vasiliy Stelmachenok <ventureo@cachyos.org>
---
 src/meson.build                            |   3 +
 src/wayland/meta-wayland-surface-private.h |   4 +
 src/wayland/meta-wayland-surface.c         |  16 ++
 src/wayland/meta-wayland-tearing-control.c | 258 +++++++++++++++++++++
 src/wayland/meta-wayland-tearing-control.h |  39 ++++
 src/wayland/meta-wayland-versions.h        |   1 +
 src/wayland/meta-wayland.c                 |   2 +
 7 files changed, 323 insertions(+)
 create mode 100644 src/wayland/meta-wayland-tearing-control.c
 create mode 100644 src/wayland/meta-wayland-tearing-control.h

diff --git a/src/meson.build b/src/meson.build
index b0c103b0c7..300e6ce1d9 100644
--- a/src/meson.build
+++ b/src/meson.build
@@ -703,6 +703,8 @@ if have_wayland
     'wayland/meta-wayland-tablet-seat.h',
     'wayland/meta-wayland-tablet-tool.c',
     'wayland/meta-wayland-tablet-tool.h',
+    'wayland/meta-wayland-tearing-control.c',
+    'wayland/meta-wayland-tearing-control.h',
     'wayland/meta-wayland-text-input.c',
     'wayland/meta-wayland-text-input.h',
     'wayland/meta-wayland-toplevel-drag.c',
@@ -1137,6 +1139,7 @@ if have_wayland
     ['session-management-v1', 'private', ],
     ['single-pixel-buffer', 'staging', 'v1', ],
     ['tablet', 'unstable', 'v2', ],
+    ['tearing-control', 'staging', 'v1', ],
     ['text-input', 'unstable', 'v3', ],
     ['viewporter', 'stable', ],
     ['xdg-activation', 'staging', 'v1', ],
diff --git a/src/wayland/meta-wayland-surface-private.h b/src/wayland/meta-wayland-surface-private.h
index fecfc82ffd..05b90bd93a 100644
--- a/src/wayland/meta-wayland-surface-private.h
+++ b/src/wayland/meta-wayland-surface-private.h
@@ -146,6 +146,9 @@ struct _MetaWaylandSurfaceState
 
   gboolean fifo_barrier;
   gboolean fifo_wait;
+
+  gboolean has_new_allow_tearing;
+  gboolean allow_tearing;
 };
 
 struct _MetaWaylandDragDestFuncs
@@ -209,6 +212,7 @@ struct _MetaWaylandSurface
     MetaMultiTexture *texture;
     int scale;
     gboolean is_valid;
+    gboolean allow_tearing;
   } applied_state, committed_state;
 
   /* Extension resources. */
diff --git a/src/wayland/meta-wayland-surface.c b/src/wayland/meta-wayland-surface.c
index 27a3abe475..b98c0af47b 100644
--- a/src/wayland/meta-wayland-surface.c
+++ b/src/wayland/meta-wayland-surface.c
@@ -427,6 +427,7 @@ meta_wayland_surface_state_set_default (MetaWaylandSurfaceState *state)
   state->dx = 0;
   state->dy = 0;
   state->scale = 0;
+  state->has_new_allow_tearing = FALSE;
 
   state->input_region = NULL;
   state->input_region_set = FALSE;
@@ -595,6 +596,12 @@ meta_wayland_surface_state_merge_into (MetaWaylandSurfaceState *from,
   if (from->scale > 0)
     to->scale = from->scale;
 
+  if (from->has_new_allow_tearing)
+    {
+      to->allow_tearing = from->allow_tearing;
+      to->has_new_allow_tearing = TRUE;
+    }
+
   if (from->has_new_buffer_transform)
     {
       to->buffer_transform = from->buffer_transform;
@@ -774,6 +781,8 @@ meta_wayland_surface_apply_state (MetaWaylandSurface      *surface,
 
   surface->applied_state.is_valid = surface->committed_state.is_valid;
 
+  surface->applied_state.allow_tearing = surface->committed_state.allow_tearing;
+
   if (surface->role)
     {
       meta_wayland_surface_role_pre_apply_state (surface->role, state);
@@ -992,6 +1001,13 @@ meta_wayland_surface_commit (MetaWaylandSurface *surface)
 
   surface->committed_state.is_valid = TRUE;
 
+  if (pending->has_new_allow_tearing)
+    {
+      surface->committed_state.allow_tearing = pending->allow_tearing;
+      pending->has_new_allow_tearing =
+        pending->allow_tearing != surface->committed_state.allow_tearing;
+    }
+
   if (pending->scale > 0)
     surface->committed_state.scale = pending->scale;
 
diff --git a/src/wayland/meta-wayland-tearing-control.c b/src/wayland/meta-wayland-tearing-control.c
new file mode 100644
index 0000000000..f7e4b2357a
--- /dev/null
+++ b/src/wayland/meta-wayland-tearing-control.c
@@ -0,0 +1,258 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+
+/*
+ * Copyright (C) 2025 Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ *
+ * Written by:
+ *     Naveen Kumar <naveen1.kumar@intel.com>
+ */
+
+#include "config.h"
+
+#include "wayland/meta-wayland-tearing-control.h"
+
+#include <wayland-server.h>
+
+#include "wayland/meta-wayland-private.h"
+#include "wayland/meta-wayland-surface-private.h"
+#include "wayland/meta-wayland-versions.h"
+
+#include "tearing-control-v1-server-protocol.h"
+
+static GQuark quark_tearing_surface_data = 0;
+
+typedef struct _MetaWaylandTearingSurface
+{
+  GObject parent_instance;
+
+  struct wl_resource *resource;
+  MetaWaylandSurface *surface;
+  gulong destroy_handler_id;
+} MetaWaylandTearingSurface;
+
+#define META_TYPE_WAYLAND_TEARING_SURFACE (meta_wayland_tearing_surface_get_type ())
+G_DECLARE_FINAL_TYPE (MetaWaylandTearingSurface,
+                      meta_wayland_tearing_surface,
+                      META, WAYLAND_TEARING_SURFACE,
+                      GObject)
+
+G_DEFINE_TYPE (MetaWaylandTearingSurface,
+               meta_wayland_tearing_surface,
+               G_TYPE_OBJECT)
+
+static void
+wp_tearing_control_set_presentation_hint (struct wl_client   *client,
+                                          struct wl_resource *resource,
+                                          uint32_t            hint_value)
+{
+  MetaWaylandTearingSurface *tearing_surface = wl_resource_get_user_data (resource);
+  MetaWaylandSurface *surface = tearing_surface->surface;
+  MetaWaylandSurfaceState *pending;
+  enum wp_tearing_control_v1_presentation_hint hint = hint_value;
+
+  if (!surface)
+    return;
+
+  pending = meta_wayland_surface_get_pending_state (surface);
+  switch (hint)
+    {
+    case WP_TEARING_CONTROL_V1_PRESENTATION_HINT_ASYNC:
+      pending->allow_tearing = TRUE;
+      break;
+    case WP_TEARING_CONTROL_V1_PRESENTATION_HINT_VSYNC:
+      pending->allow_tearing = FALSE;
+      break;
+    default:
+      wl_resource_post_error (resource, WL_DISPLAY_ERROR_INVALID_METHOD,
+                              "Invalid argument: unknown presentation hint");
+      return;
+    }
+
+  pending->has_new_allow_tearing = TRUE;
+}
+
+static void
+wp_tearing_control_destroy (struct wl_client   *client,
+                            struct wl_resource *resource)
+{
+  wl_resource_destroy (resource);
+}
+
+static const struct wp_tearing_control_v1_interface tearing_surface_interface = {
+  wp_tearing_control_set_presentation_hint,
+  wp_tearing_control_destroy,
+};
+
+static void
+wp_tearing_control_manager_destroy (struct wl_client   *client,
+                                    struct wl_resource *resource)
+{
+  wl_resource_destroy (resource);
+}
+
+static void
+clear_tearing_surface_data (MetaWaylandTearingSurface *tearing_surface)
+{
+  MetaWaylandSurfaceState *pending;
+
+  if (tearing_surface->surface)
+    {
+      g_object_set_qdata (G_OBJECT (tearing_surface->surface),
+                          quark_tearing_surface_data, NULL);
+      g_clear_signal_handler (&tearing_surface->destroy_handler_id,
+                              tearing_surface->surface);
+
+      pending = meta_wayland_surface_get_pending_state (tearing_surface->surface);
+      pending->allow_tearing = FALSE;
+      tearing_surface->surface = NULL;
+    }
+}
+
+static void
+on_surface_destroyed (MetaWaylandSurface        *surface,
+                      MetaWaylandTearingSurface *tearing_surface)
+{
+  clear_tearing_surface_data (tearing_surface);
+}
+
+static void
+tearing_control_surface_destructor (struct wl_resource *resource)
+{
+  MetaWaylandTearingSurface *tearing_surface = wl_resource_get_user_data (resource);
+
+  clear_tearing_surface_data (tearing_surface);
+
+  g_object_unref (tearing_surface);
+}
+
+static void
+meta_wayland_tearing_surface_dispose (GObject *object)
+{
+  MetaWaylandTearingSurface *tearing_surface = META_WAYLAND_TEARING_SURFACE (object);
+
+  g_clear_weak_pointer ((gpointer *) &tearing_surface->surface);
+
+  G_OBJECT_CLASS (meta_wayland_tearing_surface_parent_class)->dispose (object);
+}
+
+static void
+meta_wayland_tearing_surface_init (MetaWaylandTearingSurface *tearing_surface)
+{
+}
+
+static void
+meta_wayland_tearing_surface_class_init (MetaWaylandTearingSurfaceClass *klass)
+{
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+  object_class->dispose = meta_wayland_tearing_surface_dispose;
+}
+
+static MetaWaylandTearingSurface *
+meta_wayland_tearing_surface_new (MetaWaylandSurface *surface)
+{
+  MetaWaylandTearingSurface *tearing_surface;
+
+  tearing_surface = g_object_new (META_TYPE_WAYLAND_TEARING_SURFACE, NULL);
+  tearing_surface->surface = surface;
+  g_object_add_weak_pointer (G_OBJECT (surface),
+                             (gpointer *) &tearing_surface->surface);
+  return tearing_surface;
+}
+
+static void
+wp_tearing_control_manager_get_tearing_control (struct wl_client   *client,
+                                                struct wl_resource *resource,
+                                                uint32_t            id,
+                                                struct wl_resource *surface_resource)
+{
+  MetaWaylandSurface *surface = wl_resource_get_user_data (surface_resource);
+  g_autoptr (MetaWaylandTearingSurface) tearing_surface = NULL;
+  MetaWaylandTearingSurface *existing_tearing_surface;
+
+  existing_tearing_surface =
+    g_object_get_qdata (G_OBJECT (surface), quark_tearing_surface_data);
+
+  if (existing_tearing_surface)
+    {
+      wl_resource_post_error (resource,
+                              WP_TEARING_CONTROL_MANAGER_V1_ERROR_TEARING_CONTROL_EXISTS,
+                              "Surface already has a tearing controller");
+      return;
+    }
+
+  tearing_surface = meta_wayland_tearing_surface_new (surface);
+
+  tearing_surface->resource =
+    wl_resource_create (client,
+                        &wp_tearing_control_v1_interface,
+                        wl_resource_get_version (resource),
+                        id);
+
+  wl_resource_set_implementation (tearing_surface->resource,
+                                  &tearing_surface_interface,
+                                  g_object_ref (tearing_surface),
+                                  tearing_control_surface_destructor);
+
+  tearing_surface->destroy_handler_id =
+    g_signal_connect (tearing_surface->surface, "destroy",
+                      G_CALLBACK (on_surface_destroyed),
+                      tearing_surface);
+
+  g_object_set_qdata (G_OBJECT (surface),
+                      quark_tearing_surface_data,
+                      tearing_surface);
+}
+
+static const struct wp_tearing_control_manager_v1_interface
+tearing_control_manager_implementation = {
+  wp_tearing_control_manager_destroy,
+  wp_tearing_control_manager_get_tearing_control,
+};
+
+static void
+bind_tearing_controller (struct wl_client *client,
+                         void             *data,
+                         uint32_t          version,
+                         uint32_t          id)
+{
+  struct wl_resource *resource;
+
+  resource = wl_resource_create (client,
+                                 &wp_tearing_control_manager_v1_interface,
+                                 version, id);
+
+  wl_resource_set_implementation (resource,
+                                  &tearing_control_manager_implementation,
+                                  NULL, NULL);
+}
+
+void
+meta_wayland_tearing_controller_init (MetaWaylandCompositor *compositor)
+{
+  if (!wl_global_create (compositor->wayland_display,
+                         &wp_tearing_control_manager_v1_interface,
+                         META_WP_TEARING_CONTROL_V1_VERSION,
+                         NULL,
+                         bind_tearing_controller))
+    {
+      g_error ("Failed to register a global wp_tearing_control object");
+      return;
+    }
+
+  quark_tearing_surface_data =
+    g_quark_from_static_string ("-meta-wayland-tearing-surface-data");
+}
diff --git a/src/wayland/meta-wayland-tearing-control.h b/src/wayland/meta-wayland-tearing-control.h
new file mode 100644
index 0000000000..093b8f7d96
--- /dev/null
+++ b/src/wayland/meta-wayland-tearing-control.h
@@ -0,0 +1,39 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+
+/*
+ * Copyright (C) 2025 Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ *
+ * Written by:
+ *     Naveen Kumar <naveen1.kumar@intel.com>
+ */
+
+/*
+ * MetaWaylandTearingControl
+ *
+ * Handles passing Tearing Control in Wayland
+ *
+ * The MetaWaylandTearingControl namespace adds core support for tearing
+ * control that are passed through from clients in Wayland (e.g. using
+ * the tearing_control_staging_v1 protocol).
+ */
+
+#pragma once
+
+#include <glib.h>
+
+#include "wayland/meta-wayland-types.h"
+
+void meta_wayland_tearing_controller_init (MetaWaylandCompositor *compositor);
diff --git a/src/wayland/meta-wayland-versions.h b/src/wayland/meta-wayland-versions.h
index b928f912ca..5b01cf4a41 100644
--- a/src/wayland/meta-wayland-versions.h
+++ b/src/wayland/meta-wayland-versions.h
@@ -66,3 +66,4 @@
 #define META_WP_COMMIT_TIMING_V1_VERSION 1
 #define META_WP_FIFO_V1_VERSION 1
 #define META_WP_CURSOR_SHAPE_VERSION 2
+#define META_WP_TEARING_CONTROL_V1_VERSION 1
diff --git a/src/wayland/meta-wayland.c b/src/wayland/meta-wayland.c
index b2df0737b8..b48711c08b 100644
--- a/src/wayland/meta-wayland.c
+++ b/src/wayland/meta-wayland.c
@@ -60,6 +60,7 @@
 #include "wayland/meta-wayland-subsurface.h"
 #include "wayland/meta-wayland-system-bell.h"
 #include "wayland/meta-wayland-tablet-manager.h"
+#include "wayland/meta-wayland-tearing-control.h"
 #include "wayland/meta-wayland-transaction.h"
 #include "wayland/meta-wayland-xdg-dialog.h"
 #include "wayland/meta-wayland-xdg-foreign.h"
@@ -998,6 +999,7 @@ meta_wayland_compositor_new (MetaContext *context)
   meta_wayland_commit_timing_init (compositor);
   meta_wayland_fifo_init (compositor);
   meta_wayland_init_cursor_shape (compositor);
+  meta_wayland_tearing_controller_init (compositor);
 
 #ifdef HAVE_WAYLAND_EGLSTREAM
   {
-- 
2.50.1


From 64e46ee7f1f5465412ae4b43181ec82949bb65fb Mon Sep 17 00:00:00 2001
From: Naveen Kumar <naveen1.kumar@intel.com>
Date: Thu, 24 Oct 2024 12:06:15 +0000
Subject: [PATCH 5/7] kms/plane: Use g_autoptr & g_steal_pointer in
 update_formats

Signed-off-by: Vasiliy Stelmachenok <ventureo@cachyos.org>
---
 src/backends/native/meta-kms-plane.c | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/src/backends/native/meta-kms-plane.c b/src/backends/native/meta-kms-plane.c
index d8eef0a8bc..5b2833ecd1 100644
--- a/src/backends/native/meta-kms-plane.c
+++ b/src/backends/native/meta-kms-plane.c
@@ -342,7 +342,7 @@ free_modifier_array (GArray *array)
   if (!array)
     return;
 
-  g_array_free (array, TRUE);
+  g_array_unref (array);
 }
 
 static void
@@ -391,7 +391,7 @@ update_formats (MetaKmsPlane      *plane,
 
   for (fmt_i = 0; fmt_i < blob_fmt->count_formats; fmt_i++)
     {
-      GArray *modifiers = g_array_new (FALSE, FALSE, sizeof (uint64_t));
+      g_autoptr (GArray) modifiers = g_array_new (FALSE, FALSE, sizeof (uint64_t));
 
       if (meta_is_topic_enabled (META_DEBUG_KMS))
         {
@@ -422,13 +422,13 @@ update_formats (MetaKmsPlane      *plane,
 
       if (modifiers->len == 0)
         {
-          free_modifier_array (modifiers);
+          g_clear_pointer (&modifiers, g_array_unref);
           modifiers = NULL;
         }
 
       g_hash_table_insert (plane->formats_modifiers,
                            GUINT_TO_POINTER (formats[fmt_i]),
-                           modifiers);
+                           g_steal_pointer (&modifiers));
     }
 
   drmModeFreePropertyBlob (blob);
-- 
2.50.1


From 44b6583fb6e937b53cedee8255d478706ee97ba6 Mon Sep 17 00:00:00 2001
From: Naveen Kumar <naveen1.kumar@intel.com>
Date: Wed, 26 Feb 2025 13:51:19 +0000
Subject: [PATCH 6/7] backends/native: Add support for in_formats_async drm
 property

Introduce the new DRM property IN_FORMATS_ASYNC, allowing the
compositor to populate a list of formats and modifiers that
support tearing (async). This enables the use of appropriate
modifiers when tearing is enabled.

Kernel patchwork: https://patchwork.freedesktop.org/series/140935/

Changes in v2:
- Check for the availability of the IN_FORMATS_TEARING property.
- Utilize g_autoptr and g_steal_pointer for GArray in update_formats.
  (Sebastian Wick)

Signed-off-by: Vasiliy Stelmachenok <ventureo@cachyos.org>
---
 src/backends/native/meta-kms-plane-private.h |  1 +
 src/backends/native/meta-kms-plane.c         | 89 ++++++++++++++++++++
 2 files changed, 90 insertions(+)

diff --git a/src/backends/native/meta-kms-plane-private.h b/src/backends/native/meta-kms-plane-private.h
index c34488ec91..1e481473f0 100644
--- a/src/backends/native/meta-kms-plane-private.h
+++ b/src/backends/native/meta-kms-plane-private.h
@@ -28,6 +28,7 @@ typedef enum _MetaKmsPlaneProp
   META_KMS_PLANE_PROP_TYPE = 0,
   META_KMS_PLANE_PROP_ROTATION,
   META_KMS_PLANE_PROP_IN_FORMATS,
+  META_KMS_PLANE_PROP_IN_FORMATS_ASYNC,
   META_KMS_PLANE_PROP_SRC_X,
   META_KMS_PLANE_PROP_SRC_Y,
   META_KMS_PLANE_PROP_SRC_W,
diff --git a/src/backends/native/meta-kms-plane.c b/src/backends/native/meta-kms-plane.c
index 5b2833ecd1..6f2c3e3ba2 100644
--- a/src/backends/native/meta-kms-plane.c
+++ b/src/backends/native/meta-kms-plane.c
@@ -58,6 +58,8 @@ struct _MetaKmsPlane
    */
   GHashTable *formats_modifiers;
 
+  GHashTable *async_formats_modifiers;
+
   MetaKmsPlaneCursorSizeHints size_hints;
 
   MetaKmsPlanePropTable prop_table;
@@ -434,6 +436,80 @@ update_formats (MetaKmsPlane      *plane,
   drmModeFreePropertyBlob (blob);
 }
 
+static void
+update_async_formats (MetaKmsPlane      *plane,
+                      MetaKmsImplDevice *impl_device)
+{
+  uint64_t blob_id;
+  int fd;
+  drmModePropertyBlobPtr blob;
+  struct drm_format_modifier_blob *blob_fmt;
+  uint32_t *async_formats;
+  struct drm_format_modifier *drm_modifiers;
+  unsigned int fmt_i, mod_i;
+  MetaKmsProp *in_formats_async;
+
+  g_return_if_fail (g_hash_table_size (plane->async_formats_modifiers) == 0);
+
+  in_formats_async = &plane->prop_table.props[META_KMS_PLANE_PROP_IN_FORMATS_ASYNC];
+  if (!in_formats_async->prop_id)
+    return;
+
+  blob_id = in_formats_async->value;
+  if (blob_id == 0)
+    return;
+
+  fd = meta_kms_impl_device_get_fd (impl_device);
+  blob = drmModeGetPropertyBlob (fd, blob_id);
+  if (!blob)
+    return;
+
+  if (blob->length < sizeof (struct drm_format_modifier_blob))
+    {
+      drmModeFreePropertyBlob (blob);
+      return;
+    }
+
+  blob_fmt = blob->data;
+
+  async_formats = drm_formats_ptr (blob_fmt);
+  drm_modifiers = drm_modifiers_ptr (blob_fmt);
+
+  for (fmt_i = 0; fmt_i < blob_fmt->count_formats; fmt_i++)
+    {
+      g_autoptr (GArray) modifiers = g_array_new (FALSE, FALSE, sizeof (uint64_t));
+
+      for (mod_i = 0; mod_i < blob_fmt->count_modifiers; mod_i++)
+        {
+          struct drm_format_modifier *drm_modifier = &drm_modifiers[mod_i];
+
+          /*
+           * The modifier advertisement blob is partitioned into groups of
+           * 64 formats.
+           */
+          if (fmt_i < drm_modifier->offset || fmt_i > drm_modifier->offset + 63)
+            continue;
+
+          if (!(drm_modifier->formats & (1 << (fmt_i - drm_modifier->offset))))
+            continue;
+
+          g_array_append_val (modifiers, drm_modifier->modifier);
+        }
+
+      if (modifiers->len == 0)
+        {
+          g_clear_pointer (&modifiers, g_array_unref);
+          modifiers = NULL;
+        }
+
+      g_hash_table_insert (plane->async_formats_modifiers,
+                           GUINT_TO_POINTER (async_formats[fmt_i]),
+                           g_steal_pointer (&modifiers));
+    }
+
+  drmModeFreePropertyBlob (blob);
+}
+
 static void
 update_cursor_size_hints (MetaKmsPlane      *plane,
                           MetaKmsImplDevice *impl_device)
@@ -554,6 +630,7 @@ meta_kms_plane_read_state (MetaKmsPlane            *plane,
                                           META_KMS_PLANE_N_PROPS);
 
   update_formats (plane, impl_device);
+  update_async_formats (plane, impl_device);
   update_cursor_size_hints (plane, impl_device);
   update_rotations (plane);
   update_legacy_formats (plane, drm_plane);
@@ -683,6 +760,11 @@ init_properties (MetaKmsPlane            *plane,
           .enum_values = prop_table->color_ranges,
           .num_enum_values = META_KMS_PLANE_YCBCR_COLOR_RANGE_N_PROPS,
           .default_value = META_KMS_PLANE_YCBCR_COLOR_RANGE_LIMITED,
+	},
+      [META_KMS_PLANE_PROP_IN_FORMATS_ASYNC] =
+        {
+          .name = "IN_FORMATS_ASYNC",
+          .type = DRM_MODE_PROP_BLOB,
         },
     },
     .rotation_bitmask = {
@@ -806,6 +888,7 @@ meta_kms_plane_finalize (GObject *object)
   MetaKmsPlane *plane = META_KMS_PLANE (object);
 
   g_hash_table_destroy (plane->formats_modifiers);
+  g_hash_table_destroy (plane->async_formats_modifiers);
   g_clear_pointer (&plane->size_hints.cursor_width, g_free);
   g_clear_pointer (&plane->size_hints.cursor_height, g_free);
 
@@ -820,6 +903,12 @@ meta_kms_plane_init (MetaKmsPlane *plane)
                            g_direct_equal,
                            NULL,
                            (GDestroyNotify) free_modifier_array);
+
+  plane->async_formats_modifiers =
+    g_hash_table_new_full (g_direct_hash,
+                           g_direct_equal,
+                           NULL,
+                           (GDestroyNotify) free_modifier_array);
 }
 
 static void
-- 
2.50.1


From 9210cc1fa688d6779799458d68c74f2f536ef106 Mon Sep 17 00:00:00 2001
From: Naveen Kumar <naveen1.kumar@intel.com>
Date: Thu, 10 Apr 2025 04:51:52 +0000
Subject: [PATCH 7/7] backend/native: Add support for tearing (async page flip)

Enable tearing for clients that request it, allowing their
framebuffers to be updated asynchronously.

Fallback to sync and schedule a clutter frame update, if async
commit fails for any reason.

Signed-off-by: Vasiliy Stelmachenok <ventureo@cachyos.org>
---
 src/backends/native/meta-kms-crtc.c           |  14 +++
 src/backends/native/meta-kms-crtc.h           |   5 +
 .../native/meta-kms-impl-device-atomic.c      |  28 +++++
 src/backends/native/meta-kms-plane.c          |  16 ++-
 src/backends/native/meta-kms-plane.h          |   3 +
 src/backends/native/meta-kms-types.h          |   1 +
 src/backends/native/meta-kms-update-private.h |   8 ++
 src/backends/native/meta-kms-update.c         |  37 ++++++
 src/backends/native/meta-kms-update.h         |   5 +
 src/backends/native/meta-onscreen-native.c    | 110 +++++++++++++++---
 src/backends/native/meta-onscreen-native.h    |   5 +
 src/compositor/meta-compositor-view-native.c  |  44 ++++---
 src/wayland/meta-wayland-surface-private.h    |   2 +
 src/wayland/meta-wayland-surface.c            |   6 +
 14 files changed, 253 insertions(+), 31 deletions(-)

diff --git a/src/backends/native/meta-kms-crtc.c b/src/backends/native/meta-kms-crtc.c
index b4405a64f5..437b55c46f 100644
--- a/src/backends/native/meta-kms-crtc.c
+++ b/src/backends/native/meta-kms-crtc.c
@@ -51,6 +51,7 @@ struct _MetaKmsCrtc
   MetaKmsCrtcPropTable prop_table;
 
   gboolean is_leased;
+  gboolean is_async;
 
   int64_t shortterm_max_dispatch_duration_us;
   int64_t deadline_evasion_us;
@@ -125,6 +126,19 @@ meta_kms_crtc_set_is_leased (MetaKmsCrtc *crtc,
   crtc->is_leased = leased;
 }
 
+gboolean
+meta_kms_crtc_is_async (MetaKmsCrtc *crtc)
+{
+  return crtc->is_async;
+}
+
+void
+meta_kms_crtc_set_is_async (MetaKmsCrtc *crtc,
+                            gboolean     async)
+{
+  crtc->is_async = async;
+}
+
 static void
 read_crtc_gamma (MetaKmsCrtc       *crtc,
                  MetaKmsCrtcState  *crtc_state,
diff --git a/src/backends/native/meta-kms-crtc.h b/src/backends/native/meta-kms-crtc.h
index 411dc0cda7..15b1ce2783 100644
--- a/src/backends/native/meta-kms-crtc.h
+++ b/src/backends/native/meta-kms-crtc.h
@@ -68,6 +68,11 @@ gboolean meta_kms_crtc_is_active (MetaKmsCrtc *crtc);
 
 gboolean meta_kms_crtc_is_leased (MetaKmsCrtc *crtc);
 
+gboolean meta_kms_crtc_is_async (MetaKmsCrtc *crtc);
+
+void meta_kms_crtc_set_is_async (MetaKmsCrtc *crtc,
+                                 gboolean     async);
+
 void meta_kms_crtc_update_shortterm_max_dispatch_duration (MetaKmsCrtc *crtc,
                                                            int64_t      duration_us);
 
diff --git a/src/backends/native/meta-kms-impl-device-atomic.c b/src/backends/native/meta-kms-impl-device-atomic.c
index 7860cc2c6b..23722b9c0e 100644
--- a/src/backends/native/meta-kms-impl-device-atomic.c
+++ b/src/backends/native/meta-kms-impl-device-atomic.c
@@ -992,6 +992,8 @@ commit_flags_string (uint32_t commit_flags)
     commit_flag_strings[i++] = "PAGE_FLIP_EVENT";
   if (commit_flags & DRM_MODE_ATOMIC_TEST_ONLY)
     commit_flag_strings[i++] = "TEST_ONLY";
+  if (commit_flags & DRM_MODE_PAGE_FLIP_ASYNC)
+    commit_flag_strings[i++] = "PAGE_FLIP_ASYNC";
 
   commit_flags_string = g_strjoinv ("|", (char **) commit_flag_strings);
   strncpy (static_commit_flags_string, commit_flags_string,
@@ -1098,6 +1100,7 @@ meta_kms_impl_device_atomic_process_update (MetaKmsImplDevice *impl_device,
                                             MetaKmsUpdate     *update,
                                             MetaKmsUpdateFlag  flags)
 {
+  MetaKmsDevice *kms_device = meta_kms_impl_device_get_device (impl_device);
   GError *error = NULL;
   GList *failed_planes = NULL;
   drmModeAtomicReq *req;
@@ -1105,6 +1108,7 @@ meta_kms_impl_device_atomic_process_update (MetaKmsImplDevice *impl_device,
   int fd;
   uint32_t commit_flags = 0;
   int ret;
+  gboolean is_async = FALSE;
 
   blob_ids = g_array_new (FALSE, TRUE, sizeof (uint32_t));
 
@@ -1186,12 +1190,36 @@ meta_kms_impl_device_atomic_process_update (MetaKmsImplDevice *impl_device,
   if (flags & META_KMS_UPDATE_FLAG_TEST_ONLY)
     commit_flags |= DRM_MODE_ATOMIC_TEST_ONLY;
 
+  if ((flags & META_KMS_UPDATE_FLAG_PAGE_FLIP_ASYNC) || meta_kms_update_get_is_async (update))
+    {
+      if (meta_kms_device_supports_async_page_flip (kms_device))
+        is_async = TRUE;
+      else
+        g_warning ("[atomic] Async page flip requested but not supported; ignoring");
+    }
+
+  if (is_async)
+        commit_flags |= DRM_MODE_PAGE_FLIP_ASYNC;
+
   meta_topic (META_DEBUG_KMS,
               "[atomic] Committing update flags: %s",
               commit_flags_string (commit_flags));
 
   fd = meta_kms_impl_device_get_fd (impl_device);
   ret = drmModeAtomicCommit (fd, req, commit_flags, impl_device);
+  if (ret != 0 && is_async && commit_flags & DRM_MODE_ATOMIC_TEST_ONLY)
+    {
+      /* If we failed trying to set up a async commit, try again
+       * without async. If that succeeds, knock the async flag
+       * out of our state in case we were testing for a later commit.
+       */
+      meta_topic (META_DEBUG_KMS, "[atomic] drmModeAtomicCommit (no async, fallback)\n");
+
+      commit_flags &= ~DRM_MODE_PAGE_FLIP_ASYNC;
+      ret = drmModeAtomicCommit (fd, req, commit_flags, impl_device);
+      if (ret == 0)
+        meta_kms_update_clear_async (update);
+    }
   if (ret < 0)
     {
       g_set_error (&error, G_IO_ERROR, g_io_error_from_errno (-ret),
diff --git a/src/backends/native/meta-kms-plane.c b/src/backends/native/meta-kms-plane.c
index 6f2c3e3ba2..6e939c6a62 100644
--- a/src/backends/native/meta-kms-plane.c
+++ b/src/backends/native/meta-kms-plane.c
@@ -59,6 +59,7 @@ struct _MetaKmsPlane
   GHashTable *formats_modifiers;
 
   GHashTable *async_formats_modifiers;
+  gboolean is_async;
 
   MetaKmsPlaneCursorSizeHints size_hints;
 
@@ -209,6 +210,13 @@ meta_kms_plane_update_set_color_range (MetaKmsPlane                *plane,
     meta_kms_plane_assignment_set_color_range (plane_assignment, range);
 }
 
+void
+meta_kms_plane_update_set_async (MetaKmsPlane *plane,
+                                 gboolean      is_async)
+{
+  plane->is_async = is_async;
+}
+
 gboolean
 meta_kms_plane_is_transform_handled (MetaKmsPlane        *plane,
                                      MtkMonitorTransform  transform)
@@ -282,8 +290,12 @@ GArray *
 meta_kms_plane_get_modifiers_for_format (MetaKmsPlane *plane,
                                          uint32_t      format)
 {
-  return g_hash_table_lookup (plane->formats_modifiers,
-                              GUINT_TO_POINTER (format));
+  if (plane->is_async)
+    return g_hash_table_lookup (plane->async_formats_modifiers,
+                                GUINT_TO_POINTER (format));
+  else
+    return g_hash_table_lookup (plane->formats_modifiers,
+                                GUINT_TO_POINTER (format));
 }
 
 GArray *
diff --git a/src/backends/native/meta-kms-plane.h b/src/backends/native/meta-kms-plane.h
index adcabfc8a1..d4f015f35b 100644
--- a/src/backends/native/meta-kms-plane.h
+++ b/src/backends/native/meta-kms-plane.h
@@ -106,4 +106,7 @@ void meta_kms_plane_update_set_color_range (MetaKmsPlane                *plane,
                                             MetaKmsPlaneAssignment      *plane_assignment,
                                             MetaKmsPlaneYCbCrColorRange  range);
 
+void meta_kms_plane_update_set_async (MetaKmsPlane *plane,
+                                      gboolean      is_async);
+
 const char * meta_kms_plane_type_to_string (MetaKmsPlaneType plane_type);
diff --git a/src/backends/native/meta-kms-types.h b/src/backends/native/meta-kms-types.h
index 63530cf9d7..aa15887049 100644
--- a/src/backends/native/meta-kms-types.h
+++ b/src/backends/native/meta-kms-types.h
@@ -81,6 +81,7 @@ typedef enum _MetaKmsUpdateFlag
   META_KMS_UPDATE_FLAG_NONE = 0,
   META_KMS_UPDATE_FLAG_TEST_ONLY = 1 << 0,
   META_KMS_UPDATE_FLAG_MODE_SET = 1 << 1,
+  META_KMS_UPDATE_FLAG_PAGE_FLIP_ASYNC = 1 << 2,
 } MetaKmsUpdateFlag;
 
 typedef enum _MetaKmsPlaneType MetaKmsPlaneType;
diff --git a/src/backends/native/meta-kms-update-private.h b/src/backends/native/meta-kms-update-private.h
index e1b3924440..780b5da9b7 100644
--- a/src/backends/native/meta-kms-update-private.h
+++ b/src/backends/native/meta-kms-update-private.h
@@ -131,6 +131,10 @@ typedef struct _MetaKmsCrtcUpdate
 {
   MetaKmsCrtc *crtc;
 
+  struct {
+    gboolean is_enabled;
+  } async;
+
   struct {
     gboolean has_update;
     gboolean is_enabled;
@@ -235,6 +239,10 @@ void meta_kms_update_realize (MetaKmsUpdate     *update,
 
 gboolean meta_kms_update_get_needs_modeset (MetaKmsUpdate *update);
 
+void meta_kms_update_clear_async (MetaKmsUpdate *update);
+
+gboolean meta_kms_update_get_is_async (MetaKmsUpdate *update);
+
 MetaKmsCrtc * meta_kms_update_get_latch_crtc (MetaKmsUpdate *update);
 
 void meta_kms_page_flip_listener_unref (MetaKmsPageFlipListener *listener);
diff --git a/src/backends/native/meta-kms-update.c b/src/backends/native/meta-kms-update.c
index d37061ded1..142429b5bf 100644
--- a/src/backends/native/meta-kms-update.c
+++ b/src/backends/native/meta-kms-update.c
@@ -526,6 +526,21 @@ meta_kms_update_set_vrr (MetaKmsUpdate *update,
   update_latch_crtc (update, crtc);
 }
 
+void
+meta_kms_update_set_async (MetaKmsUpdate *update,
+                           MetaKmsCrtc   *crtc,
+                           gboolean       enabled)
+{
+  MetaKmsCrtcUpdate *crtc_update;
+
+  g_assert (meta_kms_crtc_get_device (crtc) == update->device);
+
+  crtc_update = ensure_crtc_update (update, crtc);
+  crtc_update->async.is_enabled = enabled;
+
+  update_latch_crtc (update, crtc);
+}
+
 static MetaKmsCrtcColorUpdate *
 ensure_color_update (MetaKmsUpdate *update,
                      MetaKmsCrtc   *crtc)
@@ -1168,6 +1183,28 @@ meta_kms_update_get_needs_modeset (MetaKmsUpdate *update)
   return update->needs_modeset || update->mode_sets;
 }
 
+void
+meta_kms_update_clear_async (MetaKmsUpdate *update)
+{
+  MetaKmsCrtc *latch_crtc;
+
+  latch_crtc = meta_kms_update_get_latch_crtc (update);
+  meta_kms_crtc_set_is_async (latch_crtc, FALSE);
+}
+
+gboolean
+meta_kms_update_get_is_async (MetaKmsUpdate *update)
+{
+  MetaKmsCrtcUpdate *crtc_update;
+  MetaKmsCrtc *latch_crtc;
+
+  latch_crtc = meta_kms_update_get_latch_crtc (update);
+  crtc_update = ensure_crtc_update (update, latch_crtc);
+
+  return (crtc_update->async.is_enabled &&
+          meta_kms_crtc_is_async (latch_crtc));
+}
+
 MetaKmsUpdate *
 meta_kms_update_new (MetaKmsDevice *device)
 {
diff --git a/src/backends/native/meta-kms-update.h b/src/backends/native/meta-kms-update.h
index cf08245af9..4f2b96e188 100644
--- a/src/backends/native/meta-kms-update.h
+++ b/src/backends/native/meta-kms-update.h
@@ -152,6 +152,11 @@ void meta_kms_update_set_vrr (MetaKmsUpdate *update,
                               MetaKmsCrtc   *crtc,
                               gboolean       enabled);
 
+META_EXPORT_TEST
+void meta_kms_update_set_async (MetaKmsUpdate *update,
+                                MetaKmsCrtc   *crtc,
+                                gboolean       enabled);
+
 META_EXPORT_TEST
 void meta_kms_update_set_crtc_gamma (MetaKmsUpdate      *update,
                                      MetaKmsCrtc        *crtc,
diff --git a/src/backends/native/meta-onscreen-native.c b/src/backends/native/meta-onscreen-native.c
index 48ae12894c..75ecc32907 100644
--- a/src/backends/native/meta-onscreen-native.c
+++ b/src/backends/native/meta-onscreen-native.c
@@ -128,6 +128,8 @@ struct _MetaOnscreenNative
 
   gboolean is_tearing_allowed;
 
+  gboolean tearing_enabled;
+
   MetaRendererView *view;
 
   union {
@@ -275,10 +277,19 @@ page_flip_feedback_flipped (MetaKmsCrtc  *kms_crtc,
                             gpointer      user_data)
 {
   MetaRendererView *view = user_data;
+  CoglFramebuffer *framebuffer =
+    clutter_stage_view_get_onscreen (CLUTTER_STAGE_VIEW (view));
+  CoglOnscreen *onscreen = COGL_ONSCREEN (framebuffer);
+  MetaOnscreenNative *onscreen_native = META_ONSCREEN_NATIVE (onscreen);
   struct timeval page_flip_time;
   MetaKmsDevice *kms_device;
   int64_t presentation_time_us;
-  CoglFrameInfoFlag flags = COGL_FRAME_INFO_FLAG_VSYNC;
+  CoglFrameInfoFlag flags = COGL_FRAME_INFO_FLAG_NONE;
+
+  if (!meta_onscreen_native_is_tearing_enabled (onscreen_native))
+    {
+      flags |= COGL_FRAME_INFO_FLAG_VSYNC;
+    }
 
   page_flip_time = (struct timeval) {
     .tv_sec = tv_sec,
@@ -1777,6 +1788,7 @@ meta_onscreen_native_is_buffer_scanout_compatible (CoglOnscreen *onscreen,
   MetaKmsFeedbackResult result;
   graphene_rect_t src_rect;
   MtkRectangle dst_rect;
+  MetaKmsUpdateFlag flags = META_KMS_UPDATE_FLAG_TEST_ONLY;
 
   gpu_kms = META_GPU_KMS (meta_crtc_get_gpu (crtc));
   kms_device = meta_gpu_kms_get_kms_device (gpu_kms);
@@ -1787,6 +1799,12 @@ meta_onscreen_native_is_buffer_scanout_compatible (CoglOnscreen *onscreen,
   cogl_scanout_get_src_rect (scanout, &src_rect);
   cogl_scanout_get_dst_rect (scanout, &dst_rect);
 
+  if (meta_onscreen_native_is_tearing_enabled (onscreen_native))
+    {
+      flags |= META_KMS_UPDATE_FLAG_PAGE_FLIP_ASYNC;
+      meta_kms_crtc_set_is_async (kms_crtc, TRUE);
+    }
+
   buffer = META_DRM_BUFFER (cogl_scanout_get_buffer (scanout));
   assign_primary_plane (crtc_kms,
                         buffer,
@@ -1802,7 +1820,7 @@ meta_onscreen_native_is_buffer_scanout_compatible (CoglOnscreen *onscreen,
 
   kms_feedback =
     meta_kms_device_process_update_sync (kms_device, test_update,
-                                         META_KMS_UPDATE_FLAG_TEST_ONLY);
+                                         flags);
 
   result = meta_kms_feedback_get_result (kms_feedback);
   return result == META_KMS_FEEDBACK_PASSED;
@@ -1938,15 +1956,42 @@ meta_onscreen_native_request_frame_sync (MetaOnscreenNative *onscreen_native,
   onscreen_native->frame_sync_requested = enabled;
 }
 
+void
+meta_onscreen_native_request_tearing (MetaOnscreenNative *onscreen_native,
+                                      gboolean            tearing_requested)
+{
+  MetaCrtcKms *crtc_kms = META_CRTC_KMS (onscreen_native->crtc);
+  MetaKmsCrtc *kms_crtc = meta_crtc_kms_get_kms_crtc (crtc_kms);
+  MetaKmsDevice *kms_device = meta_kms_crtc_get_device (kms_crtc);
+  MetaKmsPlane *plane = meta_crtc_kms_get_assigned_primary_plane (crtc_kms);
+
+  if (onscreen_native->is_tearing_allowed &&
+      meta_kms_device_supports_async_page_flip (kms_device))
+    {
+      if (onscreen_native->tearing_enabled != tearing_requested)
+        {
+          onscreen_native->tearing_enabled = tearing_requested;
+          meta_kms_plane_update_set_async (plane,
+                                           onscreen_native->tearing_enabled);
+        }
+    }
+}
+
 gboolean
 meta_onscreen_native_is_frame_sync_enabled (MetaOnscreenNative *onscreen_native)
 {
   return onscreen_native->frame_sync_enabled;
 }
 
+gboolean
+meta_onscreen_native_is_tearing_enabled (MetaOnscreenNative *onscreen_native)
+{
+  return onscreen_native->tearing_enabled;
+}
+
 static void
-maybe_update_frame_sync (MetaOnscreenNative *onscreen_native,
-                         ClutterFrame       *frame)
+maybe_update_frame_sync_or_tearing (MetaOnscreenNative *onscreen_native,
+                                    ClutterFrame       *frame)
 {
   MetaCrtcKms *crtc_kms = META_CRTC_KMS (onscreen_native->crtc);
   MetaKmsCrtc *kms_crtc = meta_crtc_kms_get_kms_crtc (crtc_kms);
@@ -1962,22 +2007,55 @@ maybe_update_frame_sync (MetaOnscreenNative *onscreen_native,
   gboolean frame_sync_enabled = FALSE;
 
   if (meta_output_is_vrr_enabled (onscreen_native->output))
-    frame_sync_enabled = onscreen_native->frame_sync_requested;
-
-  if (frame_sync_enabled != onscreen_native->frame_sync_enabled)
     {
-      frame_clock_mode = frame_sync_enabled ? CLUTTER_FRAME_CLOCK_MODE_VARIABLE :
-                                              CLUTTER_FRAME_CLOCK_MODE_FIXED;
-      clutter_frame_clock_set_mode (frame_clock, frame_clock_mode);
-      onscreen_native->frame_sync_enabled = frame_sync_enabled;
+      frame_sync_enabled = onscreen_native->frame_sync_requested;
+
+      if (frame_sync_enabled != onscreen_native->frame_sync_enabled)
+        {
+          frame_clock_mode = frame_sync_enabled ? CLUTTER_FRAME_CLOCK_MODE_VARIABLE :
+                                                  CLUTTER_FRAME_CLOCK_MODE_FIXED;
+          clutter_frame_clock_set_mode (frame_clock, frame_clock_mode);
+          onscreen_native->frame_sync_enabled = frame_sync_enabled;
+        }
+
+      if (crtc_state->vrr.supported &&
+          frame_sync_enabled != crtc_state->vrr.enabled)
+        {
+          kms_update = meta_frame_native_ensure_kms_update (frame_native, kms_device);
+          meta_kms_update_set_vrr (kms_update, kms_crtc, frame_sync_enabled);
+        }
     }
 
-  if (crtc_state->vrr.supported &&
-      frame_sync_enabled != crtc_state->vrr.enabled)
+  if (onscreen_native->is_tearing_allowed &&
+      meta_kms_device_supports_async_page_flip (kms_device))
     {
-      kms_update = meta_frame_native_ensure_kms_update (frame_native, kms_device);
-      meta_kms_update_set_vrr (kms_update, kms_crtc, frame_sync_enabled);
+      if (onscreen_native->tearing_enabled && meta_kms_crtc_is_async (kms_crtc))
+        {
+          clutter_stage_view_add_redraw_clip (stage_view, NULL);
+          clutter_stage_view_schedule_update_now (stage_view);
+
+          /* For asynchronous page flipping, rendering happens at irregular
+           * intervals depending on when the frame is ready and page flips
+           * are not strictly tied to the display's refresh rate */
+          frame_clock_mode = CLUTTER_FRAME_CLOCK_MODE_VARIABLE;
+          clutter_frame_clock_set_mode (frame_clock, frame_clock_mode);
+        }
+      else
+        {
+          /* switch from async to sync flip, needs a clutter frame update */
+          clutter_stage_view_add_redraw_clip (stage_view, NULL);
+          clutter_stage_view_schedule_update (stage_view);
+
+          frame_clock_mode = CLUTTER_FRAME_CLOCK_MODE_FIXED;
+          clutter_frame_clock_set_mode (frame_clock, frame_clock_mode);
+        }
+
+      kms_update = meta_frame_native_ensure_kms_update (frame_native,
+                                                        kms_device);
+      meta_kms_update_set_async (kms_update, kms_crtc,
+                                 onscreen_native->tearing_enabled);
     }
+
 }
 
 void
@@ -1994,7 +2072,7 @@ meta_onscreen_native_before_redraw (CoglOnscreen *onscreen,
       meta_kms_device_await_flush (meta_kms_crtc_get_device (kms_crtc), kms_crtc);
     }
 
-  maybe_update_frame_sync (onscreen_native, frame);
+  maybe_update_frame_sync_or_tearing (onscreen_native, frame);
 }
 
 void
diff --git a/src/backends/native/meta-onscreen-native.h b/src/backends/native/meta-onscreen-native.h
index e30357d19d..b4244513e0 100644
--- a/src/backends/native/meta-onscreen-native.h
+++ b/src/backends/native/meta-onscreen-native.h
@@ -72,3 +72,8 @@ void meta_onscreen_native_request_frame_sync (MetaOnscreenNative *onscreen_nativ
                                               gboolean            enabled);
 
 gboolean meta_onscreen_native_is_frame_sync_enabled (MetaOnscreenNative *onscreen_native);
+
+void meta_onscreen_native_request_tearing (MetaOnscreenNative *onscreen_native,
+                                           gboolean            enabled);
+
+gboolean meta_onscreen_native_is_tearing_enabled (MetaOnscreenNative *onscreen_native);
diff --git a/src/compositor/meta-compositor-view-native.c b/src/compositor/meta-compositor-view-native.c
index 1149d6080e..15b7377faa 100644
--- a/src/compositor/meta-compositor-view-native.c
+++ b/src/compositor/meta-compositor-view-native.c
@@ -162,6 +162,7 @@ find_scanout_candidate (MetaCompositorView  *compositor_view,
   ClutterColorState *output_color_state;
   ClutterColorState *surface_color_state;
   MetaWaylandSurface *surface;
+  gboolean tearing_enabled;
 
   if (meta_get_debug_paint_flags () & META_DEBUG_PAINT_DISABLE_DIRECT_SCANOUT)
     return FALSE;
@@ -206,7 +207,7 @@ find_scanout_candidate (MetaCompositorView  *compositor_view,
         {
           meta_topic (META_DEBUG_RENDER,
                       "No direct scanout candidate: using software cursor");
-          return FALSE;
+          goto err;
         }
     }
 
@@ -215,7 +216,7 @@ find_scanout_candidate (MetaCompositorView  *compositor_view,
     {
       meta_topic (META_DEBUG_RENDER,
                   "No direct scanout candidate: no KMS CRTC");
-      return FALSE;
+      goto err;
     }
 
   framebuffer = clutter_stage_view_get_onscreen (stage_view);
@@ -223,14 +224,14 @@ find_scanout_candidate (MetaCompositorView  *compositor_view,
     {
       meta_topic (META_DEBUG_RENDER,
                   "No direct scanout candidate: no onscreen framebuffer");
-      return FALSE;
+      goto err;
     }
 
   if (clutter_stage_view_has_shadowfb (stage_view))
     {
       meta_topic (META_DEBUG_RENDER,
                   "No direct scanout candidate: stage-view has shadowfb");
-      return FALSE;
+      goto err;
     }
 
   window_actor = meta_compositor_view_get_top_window_actor (compositor_view);
@@ -238,21 +239,21 @@ find_scanout_candidate (MetaCompositorView  *compositor_view,
     {
       meta_topic (META_DEBUG_RENDER,
                   "No direct scanout candidate: no top window actor");
-      return FALSE;
+      goto err;
     }
 
   if (meta_window_actor_effect_in_progress (window_actor))
     {
       meta_topic (META_DEBUG_RENDER,
                   "No direct scanout candidate: window-actor effects in progress");
-      return FALSE;
+      goto err;
     }
 
   if (clutter_actor_has_transitions (CLUTTER_ACTOR (window_actor)))
     {
       meta_topic (META_DEBUG_RENDER,
                   "No direct scanout candidate: window-actor has transition");
-      return FALSE;
+      goto err;
     }
 
   if (!clutter_actor_get_paint_box (CLUTTER_ACTOR (window_actor),
@@ -260,7 +261,7 @@ find_scanout_candidate (MetaCompositorView  *compositor_view,
     {
       meta_topic (META_DEBUG_RENDER,
                   "No direct scanout candidate: no window actor paint-box");
-      return FALSE;
+      goto err;
     }
 
   if (!G_APPROX_VALUE (actor_box.x1, view_rect.x,
@@ -278,7 +279,7 @@ find_scanout_candidate (MetaCompositorView  *compositor_view,
                   actor_box.x1, actor_box.y1,
                   actor_box.x2 - actor_box.x1, actor_box.y2 - actor_box.y1,
                   view_rect.x, view_rect.y, view_rect.width, view_rect.height);
-      return FALSE;
+      goto err;
     }
 
   surface_actor = meta_window_actor_get_scanout_candidate (window_actor);
@@ -287,7 +288,7 @@ find_scanout_candidate (MetaCompositorView  *compositor_view,
       meta_topic (META_DEBUG_RENDER,
                   "No direct scanout candidate: window-actor has no scanout "
                   "candidate");
-      return FALSE;
+      goto err;
     }
 
   output_color_state =
@@ -299,14 +300,14 @@ find_scanout_candidate (MetaCompositorView  *compositor_view,
       meta_topic (META_DEBUG_RENDER,
                   "No direct scanout candidate: "
                   "surface color state doesn't match the outputs");
-      return FALSE;
+      goto err;
     }
 
   if (meta_surface_actor_is_effectively_obscured (surface_actor))
     {
       meta_topic (META_DEBUG_RENDER,
                   "No direct scanout candidate: surface-actor is obscured");
-      return FALSE;
+      goto err;
     }
 
   surface_actor_wayland = META_SURFACE_ACTOR_WAYLAND (surface_actor);
@@ -315,7 +316,15 @@ find_scanout_candidate (MetaCompositorView  *compositor_view,
     {
       meta_topic (META_DEBUG_RENDER,
                   "No direct scanout candidate: no surface");
-      return FALSE;
+      goto err;
+    }
+
+  tearing_enabled = meta_wayland_surface_get_is_tearing_enabled (surface);
+  if (tearing_enabled !=
+      meta_onscreen_native_is_tearing_enabled (META_ONSCREEN_NATIVE (framebuffer)))
+    {
+      meta_onscreen_native_request_tearing (META_ONSCREEN_NATIVE (framebuffer),
+                                            tearing_enabled);
     }
 
   *crtc_out = crtc;
@@ -323,6 +332,15 @@ find_scanout_candidate (MetaCompositorView  *compositor_view,
   *surface_out = surface;
 
   return TRUE;
+
+err:
+  framebuffer = clutter_stage_view_get_onscreen (stage_view);
+  if (framebuffer != NULL)
+    {
+      meta_onscreen_native_request_tearing (META_ONSCREEN_NATIVE (framebuffer),
+                                            FALSE);
+    }
+  return FALSE;
 }
 
 static void
diff --git a/src/wayland/meta-wayland-surface-private.h b/src/wayland/meta-wayland-surface-private.h
index 05b90bd93a..88a2dd364d 100644
--- a/src/wayland/meta-wayland-surface-private.h
+++ b/src/wayland/meta-wayland-surface-private.h
@@ -420,6 +420,8 @@ CoglScanout *       meta_wayland_surface_try_acquire_scanout (MetaWaylandSurface
 
 MetaCrtc * meta_wayland_surface_get_scanout_candidate (MetaWaylandSurface *surface);
 
+gboolean meta_wayland_surface_get_is_tearing_enabled (MetaWaylandSurface *surface);
+
 void meta_wayland_surface_set_scanout_candidate (MetaWaylandSurface *surface,
                                                  MetaCrtc           *crtc);
 
diff --git a/src/wayland/meta-wayland-surface.c b/src/wayland/meta-wayland-surface.c
index b98c0af47b..5c45173079 100644
--- a/src/wayland/meta-wayland-surface.c
+++ b/src/wayland/meta-wayland-surface.c
@@ -2190,6 +2190,12 @@ meta_wayland_surface_role_is_on_logical_monitor (MetaWaylandSurfaceRole *surface
     return FALSE;
 }
 
+gboolean
+meta_wayland_surface_get_is_tearing_enabled (MetaWaylandSurface *surface)
+{
+  return surface->applied_state.allow_tearing;
+}
+
 static MetaWaylandSurface *
 meta_wayland_surface_role_get_toplevel (MetaWaylandSurfaceRole *surface_role)
 {
-- 
2.50.1

